## 操作系统的定义
> 操作系统(Operating System,OS)是指控制和管理整个计算机系统的硬件和软件资源,并合理地组织高度计算机的工作和资源的分配,以提供给用户和其他软件方便的接口和环境,它是计算机系统中最基本的系统软件.
> ![](assets/Screenshot%202022-02-05%20233650.png)

## 特征
### 并发
> 指两个或多个事件在同一时间间隔内发生.这些事件宏观上是同时发生的,但微观上是交替发生的.与**并行**不同,**并行**指两个或多个事件在同一时刻同时发生.  
> 操作系统的并发性指计算机系统中同时存在着多个运行着的程序.  
> 一个单核处理机(CPU)同一时刻只能执行一个程序,因此操作系统会负责协调多个程序交替执行(这此程序微观上是交替执行的,但宏观上看起来就像在同时执行)  
> 事实上,操作系统就是伴随着"多道程序技术"而出现的.因此,操作系统和程序并发是一起诞生的.  
> 当今的计算机,一般都是多核CPU,比如Intel的第八代i3处理器就是4核CPU,这意味着同一时刻可以有4个程序**并行**执行,但是操作系统的并发性依然必不可少,当代人使用计算机绝对有4个以上的程序需要同时工作.
### 共享
> 即资源共享,是指系统中的资源可供内存中多个并发执行的进程共同使用.
> + 互斥共享方式
>   > 系统中的某些资源,虽然可以提供给多个进程使用,但一个时间段内只允许一个进程访问资源.
> + 同时共享方式
>   > 系统中的某些资源,允许一个时间段内由多个进程"同时"对它们进行访问.所谓的"同时"往往是宏观上的,而在微观上,这此进程可能是交替地对该资源进行访问的(即分时共享),当然出可能出现微观上同时的情况,比如用扬声器同时放两首歌(但是我觉得只是两个进程了同一个内存区域了)

### 并发和共享的关系
![](assets/Screenshot%202022-02-06%20164836.png)

### 虚拟
> 虚拟是指把一个物理上的实体变为若干个逻辑上的对应物.物理实体(前者)是实现存在的,而逻辑上对应物(后者)是用户感觉到的.
> ![](assets/Screenshot%202022-02-06%20170037.png)


### 异步
> 在多道程序环境下,允许多个程序并发执行,但由于资源有限,进程的执行不是一贯到底的,而是走走停停,以不可预知的速度向前推进,这就是进程的异步性.

![](assets/Screenshot%202022-02-06%20171352.png)

## OS的发展阶段
![](assets/Screenshot%202022-02-07%20200105.png)
+ 手工操作阶段
  ![](assets/Screenshot%202022-02-07%20185140.png)
+ 单道批处理系统
  ![](assets/Screenshot%202022-02-07%20192252.png)
+ 多道批处理系统
  > 主要优点:多道程序并发执行,共享计算机资源.资源利用率大幅提升,CPU和其他资源保持"忙碌"状态,系统吞吐量增大.  
  > 主要缺点:用户响应时间长,没有人机交互功能(用户提交自己的作业之后就只能等待计算机处理完成,中间不能控制自己的作业执行)
  > ![](assets/Screenshot%202022-02-07%20192919.png)
+ 分时操作系统
  > 计算机以时间片为单位轮流为各个用户/作业服务,各个用户可通过终端与计算机进行交互.  
  > 主要优点:用户请求可以被即时响应,解决了人机交互问题.允许多个用户同时使用一个计算机,并且用户对计算机的操作相互独立,感受不到别人的存在.  
  > 主要缺点:不能优先处理一些紧急任务.操作系统对各个用户/作业都是完全公平的,循环地为每个用户/作业服务一个时间片,不区分任务的紧急性.  
  > ![](assets/Screenshot%202022-02-07%20194603.png)

+ 时间操作系统
  > 主要优点:能够优先响应一些紧急任务,某些紧急任务不需时间片排队.  
  > 在实时操作系统的控制下,计算机系统接收到外部信号后及时进行处理,并且要在严格的时限内处理完事件.实时操作系统的主要特点是及时性和可靠性.  
  > ![](assets/Screenshot%202022-02-07%20195504.png)

+ 其他
  1. 网络操作系统:是伴随着计算机网络的发展而诞生的,能把网络中各个计算机有机地结合起来,实现数据传送等功能,实现网络中各种资源的共享(如文件共享)和各台计算机之间的通信.(如:Windows NT 就是一种典型的网络操作系统,网站服务器就可以使用)
  2. 分布式操作系统:主要特点是分布性和并行性.系统中的各台计算机地位相同,任何工作都可以分布在这些计算机上,由它们并行,协同完成这个任务.
  3. 个人计算机操作系统:如Windows XP,MacOS,方便个人使用.

## 两种指令
> 处理器(CPU)能识别,执行的最基本命令,比如,加法指令就是让CPU进行加法运算.
+ 特权指令:不允许用户程序使用,如"内存清零指令"
+ 非特权指令:如普通的运算指令

## 两种处理器状态
> 用程序状态字寄存器(PSW)中的某标志位来标识当前处理器处于什么状态.如0为用户态,1为核心态
+ 用户态(目态):此时CPU只能执行非特权指令
+ 核心态(管态):特权指令,非特权指令都可执行

## 两种程序
+ 内核程度:操作系统的内核程序是系统的管理者,既可以执行特权指令,也可以执行非特权指令,运行在核心态.
+ 应用程序:为了保证系统能安全运行,普通应用程序只能执行非特权指令,运行在用户态.

## 操作系统的内核
> 内核是计算机上配置的底层软件,是操作系统最基本,最核心的部分.  
> 实现操作系统内核功能的那些程序就是内核程序
> ![](assets/Screenshot%202022-02-08%20192945.png)
> ![](assets/Screenshot%202022-02-08%20193254.png)

## 操作系统的体系结构D
+ 大内核
  > 将操作系统的主要功能模块都作为系统内核,运行在核心态
  + 优点:高性能
  + 缺点:内核代码庞大,结构混乱,难以维护
+ 微内核
  > 只把基本的功能保留在内核
  + 优点:内核功能少,结构清晰,方便维护
  + 缺点:需要频繁地在核心态和用户态之间切换,性能低

## 小结
![](assets/Screenshot%202022-02-08%20194513.png)

## 中断机制的诞生
> 早期的计算机,各程序只能串行执行,系统资源利用率低.  
> 为了解决这个问题,人们发明了操作系统(作为计算机制管理者),引入中断机制,实现了多道程序并发执行.  
> 本质:发生中断就意味着需要操作系统介入,开展管理工作  
> 大概流程:在用户态下,CPU收到计时部件发出的中断信号,切换为核心态对中断进行处理.操作系统内核负责对中断信号进行处理,如,进程1的时间片已用完,换进程2运行,进程2运行一段时间之后,发出系统调用(内中断信号),请求输出.CPU切换为核心态,对中断进行处理.之后,操作系统接管完成输出.

## 中断的概念和作用
1. 当中断发生时,CPU立即进入核心态
2. 当中断发生后,当前运行的进程暂停运行,并由操作系统内核对中断进行处理
3. 对于不同的中断信号,会进行不同的处理
> 发生了中断,就意味着需要操作系统介入,开展管理工作.由于操作系统的管理工作(比如进程切换,分配I/O设备等)需要使用特权指令,因此CPU要从用户态转为核心态.中断可以使CPU从用户态切换为核心态,使操作系统获得计算机的控制权.有了中断,才能实现多道程序并发执行.  
> "用户态->核心态"是通过中断实现的.并且中断是唯一途径.  
> "核心态->用户态"的切换是通过执行一个特权指令,将程序状态字(PSW)的标志位设置为"用户态"

## 中断的分类
+ 第一种分类
  ![](assets/Screenshot%202022-02-08%20211706.png)
+ 第二种分类
  ![](assets/Screenshot%202022-02-08%20211957.png)

## 外中断的处理过程
![](assets/Screenshot%202022-02-08%20212415.png)

## 小结
![](assets/Screenshot%202022-02-08%20212646.png)

## 系统调用
> 应用程序通过系统调用请求操作系统的服务.系统中的各种共享资源都由操作系统统一掌管,因此在用户程序中,凡是与资源有关的操作(如存储分配,I/O操作,文件管理等),都必须通过系统调用的方式向操作系统提出服务请求,由操作系统代为完成.这样可以保证系统的稳定性和安全性,防止用户进行非法操作.
> ![](assets/Screenshot%202022-02-09%20191226.png)

## 系统调用与库函数的区别
![](assets/Screenshot%202022-02-09%20191856.png)

## 系统调用的过程
![](assets/Screenshot%202022-02-09%20192904.png)

## 小结
![](assets/Screenshot%202022-02-09%20193206.png)

## 程序
> 就是一个指令序列,早期的计算机,只支持单道程序.  
> ps: 内存中,程序的代码放在程序段内,程序运行过程处理的数据放在数据段内(如变量).  
> ![](assets/Screenshot%202022-02-10%20190535.png)
> 程序段,数据段,PCB三部分组成了进程实体(进程映像).一般情况下,我们把进程实体就简称为进程,例如,所谓创建进程,实质上是创建进程实体中的PCB;而撤销进程,实质上是撤销进程实体中的PCB.  
> 注意:PCB是进程存在的唯一标志!  
> 从不同的角度,进程可以有不同的定义,比较传统典型的定义(强调"动态性")有:
> 1. 进程是程序的一次执行过程.
> 2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动.
> 3. 进程是具有独立功能的程序在数据集合上运行的过程,它是系统进行资源分配和调试的一个独立单位.
> 
> 引入进程实体的概念后,可把进程定义为:
> + 进程是进程实体的运行过程,是系统进行资源分配和高度的一个独立单位.
> 
> **注**: 严格来说,进程实体和进程并不一样,进程实体是静态的,进程则是动态的.不过,除非题目专门考察二者区别,否则可以认为进程实体就是进程.因此我们也可以说"进程由程序段,数据段,PCB三部分组成".

## 进程的组成
> 进程(进程实体)由程序段,数据段,PCB三部分组成
> ![](assets/Screenshot%202022-02-10%20191732.png)
> ![](assets/Screenshot%202022-02-10%20192016.png)

## 进程的组织
> 在一个系统中,通常有数十,数百乃至数千个PCB.为了能对他们加以有效的管理,应该用适当的方式把这些PCB组织起来.
> ![](assets/Screenshot%202022-02-10%20192445.png)
> + 链接方式
>   ![](assets/Screenshot%202022-02-10%20192829.png)
> + 索引方式
>   ![](assets/Screenshot%202022-02-10%20192936.png)

## 进程的特征
> 进程和程序是两个截然不同的概念,相比于程序,进程拥有以下特征:
> ![](assets/Screenshot%202022-02-10%20193327.png)

## 小结
![](assets/Screenshot%202022-02-10%20193719.png)

## 进程的状态
> 进程是程序的一次执行.在这个执行过程中,有时进程正在被CPU处理,有时又需要等待CPU服务,可见,进程的状态是会有各种变化.为了方便对各个进程的管理,操作系统需要将进程合理地划分为几种状态.
+ 运行态(Running)
  > 占有CPU,并在CPU上运行.  
  > 单核处理机环境下,每一时刻最多只有一个进程处于运行态.  
  > 双核环境下可以同时有两个进程处于运行态.
+ 就绪态(Ready)
  > 已经具备运行条件,但由于没有空闲CPU,而暂时不能运行.  
  > 进程已经拥有了除处理机之外所有需要的资源,一旦获得处理机,即可立即进入运行态开始运行.  
  > 即:万事俱备,只欠CPU.
+ 阻塞态(Waiting/Blocked,又称:等待态)
  > 因等待某一事件而暂时不能运行  
  > 如:等待操作系统分配打印机,等待读磁盘操作的结果.  
  > CPU是计算机中最昂贵的部件,为了提高CPU的利用率,需要先将其他进程需要的资源分配到位,才能得到CPU的服务.
+ 创建态(New,又称:新建态)
  > 操作系统需要完成创建进程.操作系统为该进程分配所需的内存空间等系统资源,并为其创建和初始化PCB(如:为进程分配PID)
+ 终止态(Terminated,又称:结束态)
  > 进程运行结束(或者由于bug导致进程无法继续执行下去,比如数组越界错误),需要撤销进程.  
  > 操作系统需要完成撤销进程相关的工作.完成将分配给进程的资源回收,撤销进程PCB等工作.

## 进程状态的转换
![](assets/Screenshot%202022-02-12%20195707.png)

## 小结
![](assets/Screenshot%202022-02-12%20195915.png)

## 进程控制
> 对系统中的所有进程实施有效的管理,它具有创建新进程,撤销已有进程,实现进程状态转换等功能.  
> 反正进程控制就是要实现进程状态转换.

## 进程控制流程
![](assets/Screenshot%202022-02-12%20212103.png)
![](assets/Screenshot%202022-02-12%20212350.png)

## 进程控制相关的原语
> 由于进程控制会导致进程状态的转换,所以进程控制相关的原语无非要做三类事情:
1. 更新PCB中的信息(如修改进程状态标志,将运行环境保存到PCB,从PCB恢复运行环境)
   + 所有的进程控制原语一定都会修改进程状态标志
   + 剥夺当前运行进程的CPU使用权必然需要保存其运行环境
   + 某进程开始运行前必然要恢复其运行环境
2. 将PCB插入合适的队列
3. 分配/回收资源

![](assets/Screenshot%202022-02-12%20213327.png)
![](assets/Screenshot%202022-02-12%20213556.png)
![](assets/Screenshot%202022-02-12%20214700.png)
![](assets/Screenshot%202022-02-12%20214936.png)

## 小结
![](assets/Screenshot%202022-02-12%20215054.png)

## 进程通信
> 进程之间的信息交换.  
> 进程是分配系统资源的单位(包括内存地址空间),因此各进程拥有的内存地址空间相互独立.  
> 为了保证安全,一个进程不能直接访问另一个进程的地址空间.  
> 但是进程之间的信息交换又是必须实现的.为了保证进程间的安全通信,操作系统提供了一些方法.

### 共享存储
> 两个进程对共享空间的访问必须是互斥的(互斥访问通过操作系统提供的工具实现).  
> 操作系统只负责提供共享空间和同步互斥工具(如P,V操作).
+ 基于数据结构的共享
  > 比如共享空间里只能放一个长度为10的数组.这种共享方式速度慢,限制多,是一种低级通信方式.
+ 基于存储区的共享
  > 在内存中画出一块共享存储区,数据的形式,存放位置都由进程控制,而不是操作系统.相比之下,这种共享方式速度更快,是一种高级通信方式.

### 管道通信
> "管道"是指用于连接读写进程的一个共享文件,又名pipe文件.其实就是在内存中开辟一个大小固定的缓冲区.
1. 管道只能采用半双工通信,某一时间段内只能实现单向的传输.如果要实现双向同时通信,则需要设置两个管理.
2. 各进程要互斥地访问管道.
3. 数据以字符流的形式写入管道,当管道写满时,写进程的write()系统调用将被阻塞,等待读进程将数据取走.当读进程将数据全部取走后,管道变空,此时读进程的read()系统调用将被阻塞.
4. 如果没写满,就不允许读.如果没读空,就不允许写.
5. 数据一旦被读出,就从管道中被抛弃,这就意味着读进程最多只能有一个,否则可能会有读错数据的情况.

### 消息传递
![](assets/Screenshot%202022-02-13%20195839.png)

### 小结
![](assets/Screenshot%202022-02-13%20200505.png)

## 线程
![](assets/Screenshot%202022-02-13%20201945.png)
![](assets/Screenshot%202022-02-13%20202031.png)
![](assets/Screenshot%202022-02-13%20202656.png)

### 线程的属性
![](assets/Screenshot%202022-02-13%20203112.png)

### 线程的实现方式
+ 用户级线程(User-Level Thread,ULT)
  ![](assets/Screenshot%202022-02-13%20203548.png)
+ 内核级线程(Kernel-Level Thread,KLT,又称"内核支持的线程")
  ![](assets/Screenshot%202022-02-13%20203935.png)

![](assets/Screenshot%202022-02-13%20204209.png)

### 多线程模型
1. ![](assets/Screenshot%202022-02-13%20204532.png)
2. ![](assets/Screenshot%202022-02-13%20204733.png)
3. ![](assets/Screenshot%202022-02-13%20204903.png)

### 小结
![](assets/Screenshot%202022-02-13%20205124.png)

## 调度的基本概念
> 当有一堆任务要处理,但由于资源有限,这些事情没法同时处理.这就需要确定某种规则来决定处理这些任务的顺序,这就是"调度"研究的问题.  
> 在多道程序系统中,进程的数量往往是多于处理机的个数的,这样不可能同时并行地处理各个进程.处理机调度,就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行,以实现进程的并发执行.

### 高级调度
> 由于内存空间有限,有时无法将用户提交的作业全部放入内存,因此就需要确定某种规则来决定将作业调入内存的顺序.  
> 高级调度(作业调度).按一定的原则从外存上处于后备队列的作业中挑选一个(或多个)作业,给它们分配内存等必要资源,并建立相应的进程(建立PCB),以使它(们)获得竞争处理机的权利.  
> 高级调度是辅存(外存)与内存之间的调度.每个作业只调入一次,调出一次.作业调入时建立相应的PCB,作业调出时才撤销PCB.高级调度主要是指调入的问题,因为只有调入的时机需要操作系统来确定,但调出的时机必然是作业运行结束才调出.

### 中级调度
> 引入了虚拟存储技术之后,可将暂时不能运行的进程调至外存等待.等它重新具备了运行条件且内存又稍有空间时,再重新调入内存.  
> 这么做的目的是为了提高内存利用率和系统吞吐量.  
> 暂时调到外存等待的进程状态为挂起状态.值得注意的是,PCB并不会一起调到外存,而是会常驻内存.PCB中会记录进程数据在外存中的存放位置,进程状态等信息,操作系统通过内存中的PCB来保持对各个进程的监控,管理.被挂起的进程PCB会被放到挂起队列中.  
> 中级调度(内存调度),就是要决定哪个处于挂起状态的进程重新调入内存.  
> 一个进程可能会被多次调出,调入内存,因此中级调度发生的频率要比高级调试更高.

### 七状态模型
![](assets/Screenshot%202022-02-14%20192957.png)

### 低级调度
> 低级调度(进程调试),其主要任务是按照某种方法和策略从就绪队列中选取一个进程,将处理机分配给它.  
> 进程调度是操作系统中最基本的一种调试,在一般的操作系统中都必须配置进程调度.  
> 进程调试的频率很,一般几十毫秒一次.

### 对比
|                    |                              要做什么                              |      调试发生在      | 发生频率 |         对进程状态的影响         |
| :----------------: | :----------------------------------------------------------------: | :------------------: | :------: | :------------------------------: |
| 高级调度(作业调试) | 按照某种规则,从后备队列中选择合适的作业将其调入内存,并为其创建进程 | 外在->内存(面向作业) |   最低   |        无->创建态->就绪态        |
| 中级调试(内存调度) |      按照某种规则,从扶起队列中选择合适的进程将其数据调回内存       | 外存->内存(面向进程) |   中等   | 挂起态->就绪态(阻塞挂起->阻塞态) |
| 低级调度(进程调度) |        按照某种规则,从就绪队列中选择一个进程为其分配处理机         |      内存->CPU       |   最高   |          就绪态->运行态          |

### 小结
![](assets/Screenshot%202022-02-14%20194520.png)

## 进程调度的时机
> 进程调度(低级调试),就是按照某种算法从就绪队列中选择一个进程为其分配处理机.

![](assets/Screenshot%202022-02-15%20174823.png)
![](assets/Screenshot%202022-02-15%20175331.png)
![](assets/Screenshot%202022-02-15%20175356.png)
![](assets/Screenshot%202022-02-15%20175635.png)
![](assets/Screenshot%202022-02-15%20175815.png)
![](assets/Screenshot%202022-02-15%20175913.png)

### 进程调试的方式
+ 非剥夺调度方式,又称非抢占方式
  > 只允许进程主动放弃处理机.在运行过程中即便有更紧迫的任务到达,当前进程依然会继续使用处理机,直到该进程终止或主动要求进入阻塞态.  
  > 特点是,实现简单,系统开销小但是无法及时处理紧急任务,适合于早期的批处理系统.
+ 剥夺调试方式,又称抢占方式.
  > 当一个进程正在处理机上执行时,如果有一个更重要或更紧迫的进程需要使用处理机,则立即暂停正在执行的进程,将处理机分配给更重要紧迫的那个进程.  
  > 可以优先处理更紧急的进程,也可实现让各进程按时间片轮流执行的功能(通过时钟中断).适合于分时操作系统,实时操作系统.

### 进程的切换与过程
"狭义的进程调度"与"进程切换"的区别:  
狭义的进程调试指的是从就绪队列中选中一个要运行的进程.(这个进程可以是刚刚被暂停执行的进程,也可能是另一个进程,后一种情况就需要进程切换)  
进程切换是指一个进程让出处理机,由另一个进程占用处理机的过程.  
广义的进程调试包含了选择一个进程和进程切换两个步骤.

进程切换的过程主要完成了:
1. 对原来运行进程各种数据的保存.
2. 对新的进程各种数据的恢复(如:程序计数器,程序状态字,各种数据寄存器等处理机现场信息,这些信息一般保存在进程控制块中)

注意: 进程切换是有代价的,因此如果过于频繁的进行调度,切换,必然会使整个系统的效率降低,使系统大部分时间都花在了进程切换上,而真正用于执行进程的时间减少.

### 小结
![](assets/Screenshot%202022-02-15%20182345.png)

## 调试算法的评价指标

### CPU利用率
由于早期的CPU造价极其昂贵,因此人们会希望让CPU尽可能多地工作  
CPU利用率:指CPU"忙碌"的时间占总时间的比例.

### 系统吞吐量
对于计算机来说,希望能用尽可能少的时间处理完尽可能多的作业  
系统吞吐量:单位时间内完成作业的数量


### 周转时间
![](assets/Screenshot%202022-02-16%20190731.png)
![](assets/Screenshot%202022-02-16%20191231.png)

### 等待时间
计算机的用户希望自己的作业尽可能少的等待处理机  
等待时间,指进程/作业处于等待处理机状态时间之和,等待时间越长,用户满意度越低
![](assets/Screenshot%202022-02-16%20194018.png)
对于进程来说,等待时间就是进程建立后等待被服务的时间之和,在等待I/O完成的期间其实进程也是在被服务的,所以不计入等待时间.  
对于作业来说,不仅要考虑建立进程后的等待时间,还要加上作业在外存后备队列中等待的时间.  
一个作业总共要被CPU服务多久,被I/O设备服务多久一般是确定不变的,因此调试算法其实只会影响作业/进程的等待时间.当然,与前面指标类似,也在"平均等待时间"来评价整体性能.

### 响应时间
对于计算机用户来说,会希望自己的提交的请求(比如通过键盘输入了一个调试命令)尽早地开始被系统服务,回应.  
响应时间,指从用户提交请求到首次产生响应所用的时间.

### 小结
![](assets/Screenshot%202022-02-16%20194655.png)

## FCFS,SJF,HRRN调试算法

### 先来先服务(FCFS,First Come First Serve)
![](assets/Screenshot%202022-02-17%20210626.png)

### 短作业优先(SJF,Shortest Job First)
![](assets/Screenshot%202022-02-19%20115604.png)

### 高响应比优先(HRRN,Highest Response Ratio Next)
![](assets/Screenshot%202022-02-19%20124812.png)

### 对比
|  算法   |                            可抢占                            |                        优点                         |                         缺点                         | 考虑到等待时间和运行时间 | 会导致饥饿吗 |
| :-----: | :----------------------------------------------------------: | :-------------------------------------------------: | :--------------------------------------------------: | :----------------------: | :----------: |
|  FCFS   |                           非抢占式                           |                    公平,实现简单                    |                     对短作业不利                     |      只考虑等待时间      |     不会     |
| SJF/SPF | 默认为非抢占式,也有SJF的抢占式版本最短剩余时间优先算法(SRTN) |             "最短的"平均等待和周转时间              | 对长作业不利,可能会导致饥饿.难以做到真正的短作业优先 |     只考虑了运行时间     |      会      |
|  HRRN   |                           非抢占式                           | 上述两种算法的权衡折中,综合考虑了等待时间和运行时间 |                                                      |         都考虑了         |     不会     |

注:这几种算法主要关心对用户的公平性,平均周转时间,平均等待时间等评价系统整体性能和指标,但是不关心"响应时间",也并不区分任务的紧急程度,因此对于用户来说,交互性很糟糕.因此这三种算法一般适合用于早期的批处理系统,当然,FCFS算法也常结合其他的算法使用,在现在也扮演着很重要的角色.

## 时间片轮转,优先级调试,多级反馈队列
### 时间片轮转
![](assets/Screenshot%202022-02-19%20201353.png)
![](assets/Screenshot%202022-02-19%20201438.png)

### 优先级调试算法
![](assets/Screenshot%202022-02-20%20192850.png)
![](assets/Screenshot%202022-02-20%20192726.png)

###   多级反馈队列调试算法
![](assets/Screenshot%202022-02-20%20213220.png)

### 对比
|     算法     |        可抢占         |           优点            |            缺点             | 会导致饥饿吗 |              补充              |
| :----------: | :-------------------: | :-----------------------: | :-------------------------: | :----------: | :----------------------------: |
|  时间片轮转  |        抢占式         |    公平,适用于分时系统    | 频繁切换有开销,不区分优先级 |     不会     | 时间片太小或太大会有不同的变化 |
|  优先级调试  | 有抢占式,有也非抢占式 | 区分优先级,适用于实时系统 |        可能导致饥饿         |      会      |        动态/静态优先级         |
| 多级反馈队列 |        抢占式         |         平衡优秀          |         可能会饥饿          |      会      |                                |

注:比起早期的批处理操作系统来说,由于计算机造价大幅降低,因此之后出现的交互式操作系统(包括分时操作系统,实时操作系统等)更注意系统的响应时间,公平性,平衡性等指标.而这几种算法恰好也能较好地满足交互式系统的需求.因此这三种算法适合用于交互式系统.(比如UNIX使用的就是多级反馈队列调试算法)

## 进程同步
> 同步亦称直接制约关系,它是指为完成某种任务而建立的两个或多个进程,这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系.进程间的直接制约关系就是源于它们之间的相互合作.

## 进程互斥
> 我们把一个时间段内只允许一个进程使用的资源称为临界资源.许多物理设备(比如摄像头,打印机)都属于临界资源.此外还有许多变量,数据,内存缓冲区等都属于临界资源.  
> 对临界资源的访问,必须互斥地进程.互斥,亦称间接制约关系.进程互斥指当一个进程访问某临界资源时,另一个想要访问该临界资源的进程必须等待.当前访问临界资源的进程访问结束,释放该资源之后,另一个进程才能访问临界资源.

![](assets/Screenshot%202022-02-21%20194938.png)
为了实现对临界资源的互斥访问,同时保证系统整体性能,需要遵循以下原则:
1. 空闲让进.临界区空闲时,可以允许一个请求进入临界区的进程立即进入临界区.
2. 忙则等待.当已有进程进入临界区时,其他试图进入临界区的进程必须等待.
3. 有限等待.对请求访问的进程,应保证能在有限时间内进入临界区(保证不会饥饿).
4. 让权等待.当进程不能进入临界区时,应当即释放处理机,防止进程忙等待.

### 小结
![](assets/Screenshot%202022-02-21%20195622.png)

## 进程互斥的软件实现方法

### 单标志法
> 算法思想:两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程.也就是说每个进程进入临界区的权限只能被另一个进程赋予

![](assets/Screenshot%202022-02-23%20175755.png)

### 双标志先检查法
> 算法思想:设置一个布尔型数组flag[],数组中各个元素用来标记各进程想进入临界区的意愿,比如
> ```c
> flag[0] = false;
> ```
> 意味着0号进程P0现在想要进入临界区.每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区,如果没有,则把自身对应的标志`flag[i]`设为`true`,之后开始访问临界区.

![](assets/Screenshot%202022-02-24%20203107.png)

### 双标志后检查法
> 算法思想:双标志先检查法的改版.前一个算法的问题是先"检查"后"上锁",但是这两个操作又无法一气可成,因此导致了两个进程同时进入临界区的问题.因此,人们又想到先"上锁"后"检查"的方法,来避免上述问题.

![](assets/Screenshot%202022-02-24%20203817.png)

### Peterson 算法
> 算法思想:双标志后检查法中,两个进程都争着想进入临界区,但是谁也不让谁,最后谁都无法进入临界区.Gary L. Peterson 想到了一种方法,如果双方都争着想进入临界区,那可以让进程尝试"孔融让梨",主动让对方先使用临界区.

![](assets/Screenshot%202022-02-26%20101210.png)
Peterson 算法用软件方法解决了进程互斥问题,遵循了空闲让进,忙则等待,有限等待三个原则,但是依然未遵循让权等待的原则.

### 小结
![](assets/Screenshot%202022-02-26%20102111.png)

## 进程互斥的硬件实现方法
### 中断屏蔽方法
> 利用"开/关中断指令"实现(与原语的实现思想相同,即在某进程开始访问临界区到结束访问为止都不允许被中断,也就不能发生进程切换,因此也不可能发生两个同时访问临界区的情况)

![](assets/Screenshot%202022-02-27%20200248.png)

### TestAndSet指令
> 简称TS指令,也有地方称为TestAndSetLock指令,或TSL指令.  
> TSL指令是用硬件实现的,执行的过程不允许补中断,只能一气呵成.以下是用C语言描述的**逻辑**(只能逻辑,因为这是要用硬件实现的)

![](assets/Screenshot%202022-02-27%20201641.png)

### Swap指令
> 有的地方也叫Exchange指令,或简称ECHG指令.
> Swap指令是用硬件实现的,执行的过程不允许被中断,只能一气呵成.以下是用C语言描述的逻辑

![](assets/Screenshot%202022-02-27%20203118.png)

### 小结
![](assets/Screenshot%202022-02-27%20203221.png)

## 信号量机制
> 用户进程可以通过使用操作系统提供的一个对原语来对信号量进行操作,从而很方便的实现了进程互斥,进程同步.  
> 信号量其实就是一个变量(可以是一个整数,也可以是更复杂的记录型变量),可以用一个信号量来表示系统中某种资源的数量,比如:系统中只有一台打印机,就可以设置一个初值为1的信号量.  
> 原语是一种特殊的程序段,其执行只能一气呵成,不可被中断.原语是由关中断/开中断指令实现的,软件解决方案的主要问题是由"进入区的各种操作无法一气呵成0",因此如果能把进入区,退出区的操作都用"原语"实现,使这些操作能"一气呵成"就能避免问题.  
> 一对原语: `wait(S)`原语和`signal(S)`原语,可以把原语理解为我们自己写的函数,函数名分别为wait和signal,括号里的信号量S其实就是函数调用时传入的一个参数.  
> wait,signal原语常简称为P,V操作(来处荷兰语proberen和verhogen).因此,常把`wait(S)`和`signal(S)`两个操作分别写为`P(S)`和`V(S)`.

### 整型信号量
![](assets/Screenshot%202022-03-03%20202259.png)

### 记录型信号量
![](assets/Screenshot%202022-03-03%20204027.png)
![](assets/Screenshot%202022-03-03%20205757.png)

### 小结
![](assets/Screenshot%202022-03-03%20210015.png)

## 用信号量机制实现进程互斥,同步,前驱关系
### 进程互斥
![](assets/Screenshot%202022-03-05%20123628.png)
### 进程同步
![](assets/Screenshot%202022-03-05%20123902.png)
![](assets/Screenshot%202022-03-05%20154601.png)
### 实现前驱关系
![](assets/Screenshot%202022-03-05%20162207.png)
### 小结
![](assets/Screenshot%202022-03-05%20162707.png)

## 生产者-消费者问题
系统中有一组生产者进程和一组消费者进程,生产者进程每次生产一个产品放入缓冲区,消费者进程每次从缓冲区中取出一个产品并使用.(注:这里的"产品"理解为某种数据)  
生产者,消费者共享一个初始为空,大小为n的缓冲区.  
只有缓冲区没满时,生产者才能把产品放入缓冲区,否则必须等待.  
只有缓冲区没空时,消费者才能从中取出产品,否则必须等待.  
缓冲区是临界资源,各进程必须互斥地访问.

### 实现
![](assets/Screenshot%202022-03-05%20173032.png)

## 多生产者-多消费者问题
桌子上有一个盘子,每次只能向其中放入一个水果.爸爸专向盘子中放苹果,妈妈专向盘子中放橘子,儿子专等着吃盘子中的橘子,女儿专等着吃盘子中的苹果.只有盘子空时,爸爸或妈妈才可向盘子中放一个水果.仅当盘子中有自己需要的水果时,儿子或女儿可以从盘子中取出水果.
### 实现
![](assets/Screenshot%202022-03-05%20211509.png)

## 吸烟者问题
假设一个系统有三个抽烟者进程和一个供应者进程.每个抽烟者不停地卷烟并抽掉它,但是要卷起并抽掉一支烟,抽烟者需要有三种材料:烟草,纸和胶水.三个抽烟者中,第一个拥有烟草,第二个拥有纸,第三个拥有胶水.供应者进程无限地提供三种材料,供应者每次将两种材料放桌子上,拥有剩下那种材料的抽烟者卷一根烟并抽掉它,并给供应者一个信号告诉完成了,供应者就会放另外两种材料在桌子上,这个过程一重复(让三个抽烟者轮流地抽烟)
### 实现
![](assets/Screenshot%202022-03-05%20225408.png)

## 读者-写者问题
有读者和写者两组并发进程,共享一个文件,当两个或两个以上的读进程同时访问共享数据时不会产生副作用,但若某个写进程和其他进程(读进程或写进程)同时访问共享数据可能导致数据不一致的错误.因此要求:
1. 允许多个读者可以同时对文件执行读操作
2. 只允许一个写者往文件中写信息
3. 任一写者在完成写操作之前不允许其他读者或写者工作
4. 写者执行操作前,应让已有读者和写者全部退出.
### 读者优先
![](assets/Screenshot%202022-03-06%20125145.png)
### 写者优先
![](assets/Screenshot%202022-03-06%20125853.png)

## 哲学家进餐问题
一张圆桌上坐着5名哲学家,每两个哲学家之间的桌上摆一根筷子,桌子的中间是一碗米饭.哲学家们倾注毕生的精力用于思考和进餐,哲学家在思考,并不影响他人.只有哲学家饥饿时,才试图拿起左,右两根筷子(一根一根地拿起).如果筷子已在他人手上,则需等待.饥饿的哲学家只有同时拿起两根筷子才可以开始进餐,当进餐完毕后,放下筷子继续思考.
### 实现方案
![](assets/Screenshot%202022-03-06%20184640.png)
![](assets/Screenshot%202022-03-06%20185313.png)

## 管程
管程是一种特殊的软件模块,有这些部分组成:
1. 局部于管程的共享数据结构说明
2. 对该数据结构进行操作的一组过程
3. 对局部于管程的共享数据设置初始值的语句
4. 管程有一个名字

管程的基本特征:
1. 局部于管程的数据只能被局部于管程的过程所访问
2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
3. 每次仅允许一个进程在管程内执行某个内部过程

### 用管程解决生产者消费者问题
![](assets/Screenshot%202022-03-07%20000718.png)
![](assets/Screenshot%202022-03-07%20001057.png)

### Java中类似于管程的机制
![](assets/Screenshot%202022-03-07%20001629.png)

### 小结
![](assets/Screenshot%202022-03-07%20001851.png)

## 死锁
在并发环境下,各进程因竞争资源而造成的一种互相等待对方手里的资源,导致各进程都阻塞,都无法向前推进的现象,就是"死锁".发生死锁后,若无外力干涉,这些进程都将无法向前推进.

### 死锁,饥饿,死循环的区别
+ 死锁:各进程互相等待对方手里的资源,导致各进程都阻塞,无法向前推进的现象.
+ 饥饿:由于长期得不到想要的资源,某进程无法向前推进的现象.比如,在短进程优先(SPF)算法中,若有源源不断的短进程到来,则长进程将一直得不到处理机,从而发生长进程"饥饿".
+ 死循环:某进程执行过程中一直跳不出某个循环的现象.有时是因为程序逻辑bug导致的,有时是程序员故意设计的.

![](assets/Screenshot%202022-03-10%20202832.png)

### 死锁产生的必要条件
产生死锁必须同时满足以下四个条件,只要其中任一条件不成立,死锁就不会发生.
1. 互斥条件:只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子,打印机设备).像内存,扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源).
2. 不剥夺条件:进程所获得的资源在未使用完之前,不能由其他进程强行夺走,只能主支释放.
3. 请求和保持条件:进程已经保持了至少一个资源,但又提出了新的资源请求,而该资源又被其他进程占有,此时请求进程被阻塞,但又对自己已有的资源保持不放.
4. 循环等待条件:存在一种进程资源的循环等待链,链中的每一个进程已获得的资源同时被下一个进程所请求.

注意!发生死锁时一定有循环等待,但是发生循环等待时未必死锁(循环等待是死锁的必要不充分条件).因为如果同类资源数大于1,则即使有循环等待,也未必发生死锁.但如果系统中每类资源都只有一个,那循环等待就是死锁的充分必要条件了.

### 什么时候会发生死锁
1. 对系统资源的竞争.各进程对不可剥夺的资源(如打印机)的竞争可能引起死锁,对可剥夺的资源(CPU)的竞争是不会引起死锁的.
2. 进程推进顺序非法.请求和释放资源的顺序不当,也同样会导致死锁.例如,并发执行的进程P1,P2分别申请并占有了资源R1,R2,之后进程P1又紧接着申请资源R2,而进程P2又申请资源R1,两者会因为申请的资源被对方占有而阻塞,从而发生死锁.
3. 信号量的使用不当也会造成死锁.如生产者-消费者问题中,如果实现互斥的P操作在实现同步的P操作之前,就有可能导致死锁.(可以把互斥信号量,同步信号量也看做是一种抽象的系统资源).

总之,对不可剥夺资源的不合理分配,可能导致死锁.

### 死锁的处理策略
1. 预防死锁:破坏死锁产生的四个必要条件中的一个或几个.
2. 避免死锁:用某种方法防止系统进入不安全状态,从而避免死锁(银行家算法)
3. 死锁的检测和解除.允许死锁的发生,不过操作系统会负责检测出死锁的发生,然后采取某种措施解除死锁.

### 小结
![](assets/Screenshot%202022-03-10%20211801.png)

## 预防死锁
### 破坏互斥条件
互斥条件:只有对必须互斥使用的资源的争抢才会导致死锁

如果把只能互斥使用的资源改造为允许共享使用,则系统不会进入死锁状态.比如:SPOOLing技术.  
操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备.
![](assets/Screenshot%202022-03-13%20191351.png)
该策略的缺点:并不是所有的资源都可以改造成可共享使用的资源.并且为了系统安全,很多地方还必须保护这种互斥性.因此,很多时候都无法破坏互斥条件.

### 破坏不剥夺条件
不剥夺条件:进程所获得的资源在未使用完之前,不能由其他进程强行夺走,只能主动释放.

破坏不剥夺条件:  
方案一: 当某个进程请求新的资源得不到满足时,它必须立即释放保持的所有资源,待以后需要时再重新申请.也就是说,即使某些资源尚未使用完,也需要主动释放,从而破坏了不可剥夺条件.  
方案二: 当某个进程需要的资源被其他进程所占有的时候,可以由操作系统协助,将想要的资源强行剥夺.这种方式一般需要考虑各进程的优先级(比如:剥夺调试方式,就是将处理机资源强行剥夺给优先级更高的进程使用)

该策略的缺点:
1. 实现起来比较复杂
2. 释放已获得的资源可能造成前一阶段工作的失效.因此这种方法一般只适用于易保存和恢复状态的资源,如CPU
3. 反复地申请和释放资源会增加系统开销,降低系统吞吐量
4. 若采用方案一,意味着只要暂时得不到某个资源,之前获得的那些资源就都需要放弃,以后再重新申请.如果一直发生这样的情况,就会导致进程饥饿

### 破坏请求和保持条件
请求和保持条件:进程已经保持了至少一个资源,但又提出了新的资源请求,而该资源又被其他进程占有,此时请求进程被阻塞,但又对自己已有的资源保持不放.

可以采用静态分配方法,即进程在运行前一次申请完它所需要的全部资源,在它的资源未满足前,不让投入运行.一旦投入运行后,这些资源就一直归它所有,该进程就不会再请求别的任何资源了.

该策略实现起来简单,但也有明显的缺点:  
有些资源可能只需要用很短的时间,因此如果进程的整个运行期间都一直保持着所有资源,就会造成严重的资源浪费,资源利用率极低.另外,该策略也有可能导致某些进程饥饿.

### 破坏循环等待条件
循环等待条件:存在一种进程资源的循环等待链链中的每一个进程已获得的资源同时被下一个进程所请求.

可采用顺序资源分配法.首先给系统中的资源编号,规定每个进程必须按编号递增的顺序请求资源,同类资源(即编号相同的资源)一次申请完.

原理分析:一个进程只有已占有小编号的资源时,才有资格申请更大编号的资源.按此规则,已持有大编号资源的进程不可能逆向地回来申请小编号的资源,从而就不会产生循环等待的现象

![](assets/Screenshot%202022-03-13%20200334.png)

### 小结
![](assets/Screenshot%202022-03-13%20201102.png)

## 避免死锁
### 安全序列
所谓安全序列,就是指如果系统按照这种序列分配资源,则每个进程都能顺利完成.只要能找出一个安全序列,系统就是安全状态.当然,安全序列可能有多个.  
如果分配了资源之后,系统中找不出任何一个安全序列,系统就进入了不安全状态.这就意味着之后可能所有进程都无法顺利的执行下去.当然,如果有进程提前归还了一些资源,那系统也有可能重新回到安全状态,不过我们在分配资源之前总是要考虑到最坏的情况.  
如果系统处于安全状态,就一定不会发生死锁.如果系统进入不安全状态,就可能发生死锁(处于不安全状态未必就发生了死锁,但发生了死锁时一定是在不安全状态)  
因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态,以此决定是否答应资源分配请求.这也是"银行家算法"的核心思想.

### 银行家算法
银行家算法是荷兰学者Dijkstra为银行系统设计的,以确保银行在发放现金贷款时,不会发后不能满足所有客户需要的情况.后来该算法被用在操作系统中,用于避免死锁.  
核心思想:在进程提出资源申请时,先预判此次分配是否会导致系统进入不安全状态.如果会进入不安全状态,就暂时不答应这次请求,让该进入先阻塞等待.
![](assets/Screenshot%202022-03-14%20193759.png)
![](assets/Screenshot%202022-03-14%20194042.png)

## 死锁的检测和解除
为了能对系统是否已发生了死锁进行检测,必须:
1. 用某种数据结构来保存资源的语法和分配信息
2. 提供一种算法,利用上述信息来检测系统是否已进入死锁状态

![](assets/Screenshot%202022-03-20%20144940.png)
![](assets/Screenshot%202022-03-20%20151453.png)

### 算法
![](assets/Screenshot%202022-03-22%20212323.png)

### 死锁的解除
![](assets/Screenshot%202022-03-22%20212853.png)

### 小结
![](assets/Screenshot%202022-03-22%20213039.png)


## 内存基础
### 绝对装入
在编译时,如果知道程序将放到内存中的哪个位置,编译程序将产生绝对地址的目标代码.装入程序按照装入模块中的地址,将程序和数据装入内存.  
绝对装入只适用于单道程序环境.  
程序中使用的绝对地址,可在编译或汇编时给出,也可由程序员直接赋予.通常情况下都是编译或汇编时再转换为绝对地址.

### 静态重定位
又称可重定位装入.编译,链接后的装入模块的地址都是从0开始的,指令中使用的地址,数据存放地址都是相对于起始地址而言的逻辑地址.可根据内存的当前情况,将装入模块装入到内存的适当位置.装入是对地址进行"重定位",将逻辑地址变换为物理地址(地址变换是在装入时一次完成的).  
静态重定位的特点是在一个作业装入内存时,必须分配其要求的全部内存空间,如果没有足够的内存,就不能装入该作业.作业一旦进入内存后,在运行期间就不能再移动,也不能再申请内存空间.

### 动态重定位
又称动态运行时装入.编译,链接后的装入模块的地址都是从0开始的.装入程序把装入模块装入内存后,并不会立即把逻辑地址转换为物理地址,而是把地址转换推迟到程序真正要执行时才进行.因此装入内存后所有的地址依然是逻辑地址.这种方式需要一个重定位寄存器的支持.  
采用动态重定位时允许程序在内存中发生移动.  
并且可将程序分配到不连续的存储区中;在程序运行前中需装入它的部分代码即可投入运行,然后在程序运行期间,根据需要动态申请分配内存;便于程序段的共享,可以向用户提供一个比存储空间大得多的地址空间.

### 链接的三种方式
![](assets/Screenshot%202022-03-23%20205443.png)

### 小结
![](assets/Screenshot%202022-03-23%20205809.png)

## 内存管理
1. 操作系统负责内存空间的分配与回收
2. 操作系统需要提供某种技术从逻辑上对内存空间进行扩充
3. 操作系统需要提供地址转换功能,负责程序的逻辑地址与物理地址的转换
4. 操作系统需要提供内存保护功能.保证各进程在各自存储空间内运行,互不干扰
   + 方案一,在CPU中设置一对上,下限寄存器,存放进程的上,下限地址.进程的指令要访问某个地址时,CPU检查是否越界
   + 方案二,采用重定位寄存器(又称基址寄存器)和界地址寄存器(又称限长寄存器)进行越界检查.重定位寄存器中存放的是进程的起始物理地址.界地址寄存器中存放的是进程的最大逻辑地址

### 小结
![](assets/Screenshot%202022-03-24%20193648.png)

## 覆盖与交换
### 覆盖技术
将程序分为多个段(多个模块).常用的段常驻内存,不常用的段在需要时调入内存.  
内存中分类一个"固定区"和若干个"覆盖区".  
需要常驻内存的段放在"固定区"中,调入后就不再调出(除非运行结束)  
不常用的段放在"覆盖区",需要用到时调入内存,用不到时调出内存
![](assets/Screenshot%202022-03-28%20202743.png)

### 交换技术
内存空间紧张时,系统将内存中某些进程暂时换出外存,把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调试)
![](assets/Screenshot%202022-03-28%20210416.png)
![](assets/Screenshot%202022-03-28%20211112.png)

### 小结
![](assets/Screenshot%202022-03-28%20211325.png)

## 连续分配管理方式
### 单一连续分配
![](assets/Screenshot%202022-04-18%20200004.png)

### 固定分区分配
![](assets/Screenshot%202022-04-18%20200502.png)











