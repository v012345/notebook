## 操作系统的定义

> 操作系统(Operating System,OS)是指控制和管理整个计算机系统的硬件和软件资源,并合理地组织高度计算机的工作和资源的分配,以提供给用户和其他软件方便的接口和环境,它是计算机系统中最基本的系统软件.
> ![image](assets/Screenshot%202022-02-05%20233650.png)

## 特征

### 并发

> 指两个或多个事件在同一时间间隔内发生.这些事件宏观上是同时发生的,但微观上是交替发生的.与**并行**不同,**并行**指两个或多个事件在同一时刻同时发生.  
> 操作系统的并发性指计算机系统中同时存在着多个运行着的程序.  
> 一个单核处理机(CPU)同一时刻只能执行一个程序,因此操作系统会负责协调多个程序交替执行(这此程序微观上是交替执行的,但宏观上看起来就像在同时执行)  
> 事实上,操作系统就是伴随着"多道程序技术"而出现的.因此,操作系统和程序并发是一起诞生的.  
> 当今的计算机,一般都是多核CPU,比如Intel的第八代i3处理器就是4核CPU,这意味着同一时刻可以有4个程序**并行**执行,但是操作系统的并发性依然必不可少,当代人使用计算机绝对有4个以上的程序需要同时工作.

### 共享

> 即资源共享,是指系统中的资源可供内存中多个并发执行的进程共同使用.
>
> + 互斥共享方式
>
> > 系统中的某些资源,虽然可以提供给多个进程使用,但一个时间段内只允许一个进程访问资源.
>
> + 同时共享方式
>
> > 系统中的某些资源,允许一个时间段内由多个进程"同时"对它们进行访问.所谓的"同时"往往是宏观上的,而在微观上,这此进程可能是交替地对该资源进行访问的(即分时共享),当然出可能出现微观上同时的情况,比如用扬声器同时放两首歌(但是我觉得只是两个进程了同一个内存区域了)

### 并发和共享的关系

![image](assets/Screenshot%202022-02-06%20164836.png)

### 虚拟

> 虚拟是指把一个物理上的实体变为若干个逻辑上的对应物.物理实体(前者)是实现存在的,而逻辑上对应物(后者)是用户感觉到的.
> ![image](assets/Screenshot%202022-02-06%20170037.png)

### 异步

> 在多道程序环境下,允许多个程序并发执行,但由于资源有限,进程的执行不是一贯到底的,而是走走停停,以不可预知的速度向前推进,这就是进程的异步性.

![image](assets/Screenshot%202022-02-06%20171352.png)

## OS的发展阶段

![image](assets/Screenshot%202022-02-07%20200105.png)

+ 手工操作阶段
  ![image](assets/Screenshot%202022-02-07%20185140.png)
+ 单道批处理系统
  ![image](assets/Screenshot%202022-02-07%20192252.png)
+ 多道批处理系统
  > 主要优点:多道程序并发执行,共享计算机资源.资源利用率大幅提升,CPU和其他资源保持"忙碌"状态,系统吞吐量增大.  
  > 主要缺点:用户响应时间长,没有人机交互功能(用户提交自己的作业之后就只能等待计算机处理完成,中间不能控制自己的作业执行)
  > ![image](assets/Screenshot%202022-02-07%20192919.png)
+ 分时操作系统
  > 计算机以时间片为单位轮流为各个用户/作业服务,各个用户可通过终端与计算机进行交互.  
  > 主要优点:用户请求可以被即时响应,解决了人机交互问题.允许多个用户同时使用一个计算机,并且用户对计算机的操作相互独立,感受不到别人的存在.  
  > 主要缺点:不能优先处理一些紧急任务.操作系统对各个用户/作业都是完全公平的,循环地为每个用户/作业服务一个时间片,不区分任务的紧急性.  
  > ![image](assets/Screenshot%202022-02-07%20194603.png)

+ 时间操作系统
  > 主要优点:能够优先响应一些紧急任务,某些紧急任务不需时间片排队.  
  > 在实时操作系统的控制下,计算机系统接收到外部信号后及时进行处理,并且要在严格的时限内处理完事件.实时操作系统的主要特点是及时性和可靠性.  
  > ![image](assets/Screenshot%202022-02-07%20195504.png)

+ 其他
  1. 网络操作系统:是伴随着计算机网络的发展而诞生的,能把网络中各个计算机有机地结合起来,实现数据传送等功能,实现网络中各种资源的共享(如文件共享)和各台计算机之间的通信.(如:Windows NT 就是一种典型的网络操作系统,网站服务器就可以使用)
  2. 分布式操作系统:主要特点是分布性和并行性.系统中的各台计算机地位相同,任何工作都可以分布在这些计算机上,由它们并行,协同完成这个任务.
  3. 个人计算机操作系统:如Windows XP,MacOS,方便个人使用.

## 两种指令

> 处理器(CPU)能识别,执行的最基本命令,比如,加法指令就是让CPU进行加法运算.

+ 特权指令:不允许用户程序使用,如"内存清零指令"
+ 非特权指令:如普通的运算指令

## 两种处理器状态

> 用程序状态字寄存器(PSW)中的某标志位来标识当前处理器处于什么状态.如0为用户态,1为核心态

+ 用户态(目态):此时CPU只能执行非特权指令
+ 核心态(管态):特权指令,非特权指令都可执行

## 两种程序

+ 内核程度:操作系统的内核程序是系统的管理者,既可以执行特权指令,也可以执行非特权指令,运行在核心态.
+ 应用程序:为了保证系统能安全运行,普通应用程序只能执行非特权指令,运行在用户态.

## 操作系统的内核

> 内核是计算机上配置的底层软件,是操作系统最基本,最核心的部分.  
> 实现操作系统内核功能的那些程序就是内核程序
> ![image](assets/Screenshot%202022-02-08%20192945.png)
> ![image](assets/Screenshot%202022-02-08%20193254.png)

## 操作系统的体系结构D

+ 大内核
  > 将操作系统的主要功能模块都作为系统内核,运行在核心态
  + 优点:高性能
  + 缺点:内核代码庞大,结构混乱,难以维护
+ 微内核
  > 只把基本的功能保留在内核
  + 优点:内核功能少,结构清晰,方便维护
  + 缺点:需要频繁地在核心态和用户态之间切换,性能低

## 小结

![image](assets/Screenshot%202022-02-08%20194513.png)

## 中断机制的诞生

> 早期的计算机,各程序只能串行执行,系统资源利用率低.  
> 为了解决这个问题,人们发明了操作系统(作为计算机制管理者),引入中断机制,实现了多道程序并发执行.  
> 本质:发生中断就意味着需要操作系统介入,开展管理工作  
> 大概流程:在用户态下,CPU收到计时部件发出的中断信号,切换为核心态对中断进行处理.操作系统内核负责对中断信号进行处理,如,进程1的时间片已用完,换进程2运行,进程2运行一段时间之后,发出系统调用(内中断信号),请求输出.CPU切换为核心态,对中断进行处理.之后,操作系统接管完成输出.

## 中断的概念和作用

1. 当中断发生时,CPU立即进入核心态
2. 当中断发生后,当前运行的进程暂停运行,并由操作系统内核对中断进行处理
3. 对于不同的中断信号,会进行不同的处理

> 发生了中断,就意味着需要操作系统介入,开展管理工作.由于操作系统的管理工作(比如进程切换,分配I/O设备等)需要使用特权指令,因此CPU要从用户态转为核心态.中断可以使CPU从用户态切换为核心态,使操作系统获得计算机的控制权.有了中断,才能实现多道程序并发执行.  
> "用户态->核心态"是通过中断实现的.并且中断是唯一途径.  
> "核心态->用户态"的切换是通过执行一个特权指令,将程序状态字(PSW)的标志位设置为"用户态"

## 中断的分类

+ 第一种分类
  ![image](assets/Screenshot%202022-02-08%20211706.png)
+ 第二种分类
  ![image](assets/Screenshot%202022-02-08%20211957.png)

## 外中断的处理过程

![image](assets/Screenshot%202022-02-08%20212415.png)

## 小结

![image](assets/Screenshot%202022-02-08%20212646.png)

## 系统调用

> 应用程序通过系统调用请求操作系统的服务.系统中的各种共享资源都由操作系统统一掌管,因此在用户程序中,凡是与资源有关的操作(如存储分配,I/O操作,文件管理等),都必须通过系统调用的方式向操作系统提出服务请求,由操作系统代为完成.这样可以保证系统的稳定性和安全性,防止用户进行非法操作.
> ![image](assets/Screenshot%202022-02-09%20191226.png)

## 系统调用与库函数的区别

![image](assets/Screenshot%202022-02-09%20191856.png)

## 系统调用的过程

![image](assets/Screenshot%202022-02-09%20192904.png)

## 小结

![image](assets/Screenshot%202022-02-09%20193206.png)

## 程序

> 就是一个指令序列,早期的计算机,只支持单道程序.  
> ps: 内存中,程序的代码放在程序段内,程序运行过程处理的数据放在数据段内(如变量).  
> ![image](assets/Screenshot%202022-02-10%20190535.png)
> 程序段,数据段,PCB三部分组成了进程实体(进程映像).一般情况下,我们把进程实体就简称为进程,例如,所谓创建进程,实质上是创建进程实体中的PCB;而撤销进程,实质上是撤销进程实体中的PCB.  
> 注意:PCB是进程存在的唯一标志!  
> 从不同的角度,进程可以有不同的定义,比较传统典型的定义(强调"动态性")有:
>
> 1. 进程是程序的一次执行过程.
> 2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动.
> 3. 进程是具有独立功能的程序在数据集合上运行的过程,它是系统进行资源分配和调试的一个独立单位.
>
> 引入进程实体的概念后,可把进程定义为:
>
> + 进程是进程实体的运行过程,是系统进行资源分配和高度的一个独立单位.
>
> **注**: 严格来说,进程实体和进程并不一样,进程实体是静态的,进程则是动态的.不过,除非题目专门考察二者区别,否则可以认为进程实体就是进程.因此我们也可以说"进程由程序段,数据段,PCB三部分组成".

## 进程的组成

> 进程(进程实体)由程序段,数据段,PCB三部分组成
> ![image](assets/Screenshot%202022-02-10%20191732.png)
> ![image](assets/Screenshot%202022-02-10%20192016.png)

## 进程的组织

> 在一个系统中,通常有数十,数百乃至数千个PCB.为了能对他们加以有效的管理,应该用适当的方式把这些PCB组织起来.
> ![image](assets/Screenshot%202022-02-10%20192445.png)
>
> + 链接方式
>   ![image](assets/Screenshot%202022-02-10%20192829.png)
> + 索引方式
>   ![image](assets/Screenshot%202022-02-10%20192936.png)

## 进程的特征

> 进程和程序是两个截然不同的概念,相比于程序,进程拥有以下特征:
> ![image](assets/Screenshot%202022-02-10%20193327.png)

## 小结

![image](assets/Screenshot%202022-02-10%20193719.png)

## 进程的状态

> 进程是程序的一次执行.在这个执行过程中,有时进程正在被CPU处理,有时又需要等待CPU服务,可见,进程的状态是会有各种变化.为了方便对各个进程的管理,操作系统需要将进程合理地划分为几种状态.

+ 运行态(Running)
  > 占有CPU,并在CPU上运行.  
  > 单核处理机环境下,每一时刻最多只有一个进程处于运行态.  
  > 双核环境下可以同时有两个进程处于运行态.
+ 就绪态(Ready)
  > 已经具备运行条件,但由于没有空闲CPU,而暂时不能运行.  
  > 进程已经拥有了除处理机之外所有需要的资源,一旦获得处理机,即可立即进入运行态开始运行.  
  > 即:万事俱备,只欠CPU.
+ 阻塞态(Waiting/Blocked,又称:等待态)
  > 因等待某一事件而暂时不能运行  
  > 如:等待操作系统分配打印机,等待读磁盘操作的结果.  
  > CPU是计算机中最昂贵的部件,为了提高CPU的利用率,需要先将其他进程需要的资源分配到位,才能得到CPU的服务.
+ 创建态(New,又称:新建态)
  > 操作系统需要完成创建进程.操作系统为该进程分配所需的内存空间等系统资源,并为其创建和初始化PCB(如:为进程分配PID)
+ 终止态(Terminated,又称:结束态)
  > 进程运行结束(或者由于bug导致进程无法继续执行下去,比如数组越界错误),需要撤销进程.  
  > 操作系统需要完成撤销进程相关的工作.完成将分配给进程的资源回收,撤销进程PCB等工作.

## 进程状态的转换

![image](assets/Screenshot%202022-02-12%20195707.png)

## 小结

![image](assets/Screenshot%202022-02-12%20195915.png)

## 进程控制

> 对系统中的所有进程实施有效的管理,它具有创建新进程,撤销已有进程,实现进程状态转换等功能.  
> 反正进程控制就是要实现进程状态转换.

## 进程控制流程

![image](assets/Screenshot%202022-02-12%20212103.png)
![image](assets/Screenshot%202022-02-12%20212350.png)

## 进程控制相关的原语

> 由于进程控制会导致进程状态的转换,所以进程控制相关的原语无非要做三类事情:

1. 更新PCB中的信息(如修改进程状态标志,将运行环境保存到PCB,从PCB恢复运行环境)
   + 所有的进程控制原语一定都会修改进程状态标志
   + 剥夺当前运行进程的CPU使用权必然需要保存其运行环境
   + 某进程开始运行前必然要恢复其运行环境
2. 将PCB插入合适的队列
3. 分配/回收资源

![image](assets/Screenshot%202022-02-12%20213327.png)
![image](assets/Screenshot%202022-02-12%20213556.png)
![image](assets/Screenshot%202022-02-12%20214700.png)
![image](assets/Screenshot%202022-02-12%20214936.png)

## 小结

![image](assets/Screenshot%202022-02-12%20215054.png)

## 进程通信

> 进程之间的信息交换.  
> 进程是分配系统资源的单位(包括内存地址空间),因此各进程拥有的内存地址空间相互独立.  
> 为了保证安全,一个进程不能直接访问另一个进程的地址空间.  
> 但是进程之间的信息交换又是必须实现的.为了保证进程间的安全通信,操作系统提供了一些方法.

### 共享存储

> 两个进程对共享空间的访问必须是互斥的(互斥访问通过操作系统提供的工具实现).  
> 操作系统只负责提供共享空间和同步互斥工具(如P,V操作).

+ 基于数据结构的共享
  > 比如共享空间里只能放一个长度为10的数组.这种共享方式速度慢,限制多,是一种低级通信方式.
+ 基于存储区的共享
  > 在内存中画出一块共享存储区,数据的形式,存放位置都由进程控制,而不是操作系统.相比之下,这种共享方式速度更快,是一种高级通信方式.

### 管道通信

> "管道"是指用于连接读写进程的一个共享文件,又名pipe文件.其实就是在内存中开辟一个大小固定的缓冲区.

1. 管道只能采用半双工通信,某一时间段内只能实现单向的传输.如果要实现双向同时通信,则需要设置两个管理.
2. 各进程要互斥地访问管道.
3. 数据以字符流的形式写入管道,当管道写满时,写进程的write()系统调用将被阻塞,等待读进程将数据取走.当读进程将数据全部取走后,管道变空,此时读进程的read()系统调用将被阻塞.
4. 如果没写满,就不允许读.如果没读空,就不允许写.
5. 数据一旦被读出,就从管道中被抛弃,这就意味着读进程最多只能有一个,否则可能会有读错数据的情况.

### 消息传递

![image](assets/Screenshot%202022-02-13%20195839.png)

### 小结

![image](assets/Screenshot%202022-02-13%20200505.png)

## 线程

![image](assets/Screenshot%202022-02-13%20201945.png)
![image](assets/Screenshot%202022-02-13%20202031.png)
![image](assets/Screenshot%202022-02-13%20202656.png)

### 线程的属性

![image](assets/Screenshot%202022-02-13%20203112.png)

### 线程的实现方式

+ 用户级线程(User-Level Thread,ULT)
  ![image](assets/Screenshot%202022-02-13%20203548.png)
+ 内核级线程(Kernel-Level Thread,KLT,又称"内核支持的线程")
  ![image](assets/Screenshot%202022-02-13%20203935.png)

![image](assets/Screenshot%202022-02-13%20204209.png)

### 多线程模型

1. ![image](assets/Screenshot%202022-02-13%20204532.png)
2. ![image](assets/Screenshot%202022-02-13%20204733.png)
3. ![image](assets/Screenshot%202022-02-13%20204903.png)

### 小结

![image](assets/Screenshot%202022-02-13%20205124.png)

## 调度的基本概念

> 当有一堆任务要处理,但由于资源有限,这些事情没法同时处理.这就需要确定某种规则来决定处理这些任务的顺序,这就是"调度"研究的问题.  
> 在多道程序系统中,进程的数量往往是多于处理机的个数的,这样不可能同时并行地处理各个进程.处理机调度,就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行,以实现进程的并发执行.

### 高级调度

> 由于内存空间有限,有时无法将用户提交的作业全部放入内存,因此就需要确定某种规则来决定将作业调入内存的顺序.  
> 高级调度(作业调度).按一定的原则从外存上处于后备队列的作业中挑选一个(或多个)作业,给它们分配内存等必要资源,并建立相应的进程(建立PCB),以使它(们)获得竞争处理机的权利.  
> 高级调度是辅存(外存)与内存之间的调度.每个作业只调入一次,调出一次.作业调入时建立相应的PCB,作业调出时才撤销PCB.高级调度主要是指调入的问题,因为只有调入的时机需要操作系统来确定,但调出的时机必然是作业运行结束才调出.

### 中级调度

> 引入了虚拟存储技术之后,可将暂时不能运行的进程调至外存等待.等它重新具备了运行条件且内存又稍有空间时,再重新调入内存.  
> 这么做的目的是为了提高内存利用率和系统吞吐量.  
> 暂时调到外存等待的进程状态为挂起状态.值得注意的是,PCB并不会一起调到外存,而是会常驻内存.PCB中会记录进程数据在外存中的存放位置,进程状态等信息,操作系统通过内存中的PCB来保持对各个进程的监控,管理.被挂起的进程PCB会被放到挂起队列中.  
> 中级调度(内存调度),就是要决定哪个处于挂起状态的进程重新调入内存.  
> 一个进程可能会被多次调出,调入内存,因此中级调度发生的频率要比高级调试更高.

### 七状态模型

![image](assets/Screenshot%202022-02-14%20192957.png)

### 低级调度

> 低级调度(进程调试),其主要任务是按照某种方法和策略从就绪队列中选取一个进程,将处理机分配给它.  
> 进程调度是操作系统中最基本的一种调试,在一般的操作系统中都必须配置进程调度.  
> 进程调试的频率很,一般几十毫秒一次.

### 对比

|                    |                              要做什么                              |      调试发生在      | 发生频率 |         对进程状态的影响         |
| :----------------: | :----------------------------------------------------------------: | :------------------: | :------: | :------------------------------: |
| 高级调度(作业调试) | 按照某种规则,从后备队列中选择合适的作业将其调入内存,并为其创建进程 | 外在->内存(面向作业) |   最低   |        无->创建态->就绪态        |
| 中级调试(内存调度) |      按照某种规则,从扶起队列中选择合适的进程将其数据调回内存       | 外存->内存(面向进程) |   中等   | 挂起态->就绪态(阻塞挂起->阻塞态) |
| 低级调度(进程调度) |        按照某种规则,从就绪队列中选择一个进程为其分配处理机         |      内存->CPU       |   最高   |          就绪态->运行态          |

### 小结

![image](assets/Screenshot%202022-02-14%20194520.png)

## 进程调度的时机

> 进程调度(低级调试),就是按照某种算法从就绪队列中选择一个进程为其分配处理机.

![image](assets/Screenshot%202022-02-15%20174823.png)
![image](assets/Screenshot%202022-02-15%20175331.png)
![image](assets/Screenshot%202022-02-15%20175356.png)
![image](assets/Screenshot%202022-02-15%20175635.png)
![image](assets/Screenshot%202022-02-15%20175815.png)
![image](assets/Screenshot%202022-02-15%20175913.png)

### 进程调试的方式

+ 非剥夺调度方式,又称非抢占方式
  > 只允许进程主动放弃处理机.在运行过程中即便有更紧迫的任务到达,当前进程依然会继续使用处理机,直到该进程终止或主动要求进入阻塞态.  
  > 特点是,实现简单,系统开销小但是无法及时处理紧急任务,适合于早期的批处理系统.
+ 剥夺调试方式,又称抢占方式.
  > 当一个进程正在处理机上执行时,如果有一个更重要或更紧迫的进程需要使用处理机,则立即暂停正在执行的进程,将处理机分配给更重要紧迫的那个进程.  
  > 可以优先处理更紧急的进程,也可实现让各进程按时间片轮流执行的功能(通过时钟中断).适合于分时操作系统,实时操作系统.

### 进程的切换与过程

"狭义的进程调度"与"进程切换"的区别:  
狭义的进程调试指的是从就绪队列中选中一个要运行的进程.(这个进程可以是刚刚被暂停执行的进程,也可能是另一个进程,后一种情况就需要进程切换)  
进程切换是指一个进程让出处理机,由另一个进程占用处理机的过程.  
广义的进程调试包含了选择一个进程和进程切换两个步骤.

进程切换的过程主要完成了:

1. 对原来运行进程各种数据的保存.
2. 对新的进程各种数据的恢复(如:程序计数器,程序状态字,各种数据寄存器等处理机现场信息,这些信息一般保存在进程控制块中)

注意: 进程切换是有代价的,因此如果过于频繁的进行调度,切换,必然会使整个系统的效率降低,使系统大部分时间都花在了进程切换上,而真正用于执行进程的时间减少.

### 小结

![image](assets/Screenshot%202022-02-15%20182345.png)

## 调试算法的评价指标

### CPU利用率

由于早期的CPU造价极其昂贵,因此人们会希望让CPU尽可能多地工作  
CPU利用率:指CPU"忙碌"的时间占总时间的比例.

### 系统吞吐量

对于计算机来说,希望能用尽可能少的时间处理完尽可能多的作业  
系统吞吐量:单位时间内完成作业的数量

### 周转时间

![image](assets/Screenshot%202022-02-16%20190731.png)
![image](assets/Screenshot%202022-02-16%20191231.png)

### 等待时间

计算机的用户希望自己的作业尽可能少的等待处理机  
等待时间,指进程/作业处于等待处理机状态时间之和,等待时间越长,用户满意度越低
![image](assets/Screenshot%202022-02-16%20194018.png)
对于进程来说,等待时间就是进程建立后等待被服务的时间之和,在等待I/O完成的期间其实进程也是在被服务的,所以不计入等待时间.  
对于作业来说,不仅要考虑建立进程后的等待时间,还要加上作业在外存后备队列中等待的时间.  
一个作业总共要被CPU服务多久,被I/O设备服务多久一般是确定不变的,因此调试算法其实只会影响作业/进程的等待时间.当然,与前面指标类似,也在"平均等待时间"来评价整体性能.

### 响应时间

对于计算机用户来说,会希望自己的提交的请求(比如通过键盘输入了一个调试命令)尽早地开始被系统服务,回应.  
响应时间,指从用户提交请求到首次产生响应所用的时间.

### 小结

![image](assets/Screenshot%202022-02-16%20194655.png)

## FCFS,SJF,HRRN调试算法

### 先来先服务(FCFS,First Come First Serve)

![image](assets/Screenshot%202022-02-17%20210626.png)

### 短作业优先(SJF,Shortest Job First)

![image](assets/Screenshot%202022-02-19%20115604.png)

### 高响应比优先(HRRN,Highest Response Ratio Next)

![image](assets/Screenshot%202022-02-19%20124812.png)

### 对比

|  算法   |                            可抢占                            |                        优点                         |                         缺点                         | 考虑到等待时间和运行时间 | 会导致饥饿吗 |
| :-----: | :----------------------------------------------------------: | :-------------------------------------------------: | :--------------------------------------------------: | :----------------------: | :----------: |
|  FCFS   |                           非抢占式                           |                    公平,实现简单                    |                     对短作业不利                     |      只考虑等待时间      |     不会     |
| SJF/SPF | 默认为非抢占式,也有SJF的抢占式版本最短剩余时间优先算法(SRTN) |             "最短的"平均等待和周转时间              | 对长作业不利,可能会导致饥饿.难以做到真正的短作业优先 |     只考虑了运行时间     |      会      |
|  HRRN   |                           非抢占式                           | 上述两种算法的权衡折中,综合考虑了等待时间和运行时间 |                                                      |         都考虑了         |     不会     |

注:这几种算法主要关心对用户的公平性,平均周转时间,平均等待时间等评价系统整体性能和指标,但是不关心"响应时间",也并不区分任务的紧急程度,因此对于用户来说,交互性很糟糕.因此这三种算法一般适合用于早期的批处理系统,当然,FCFS算法也常结合其他的算法使用,在现在也扮演着很重要的角色.

## 时间片轮转,优先级调试,多级反馈队列

### 时间片轮转

![image](assets/Screenshot%202022-02-19%20201353.png)
![image](assets/Screenshot%202022-02-19%20201438.png)

### 优先级调试算法

![image](assets/Screenshot%202022-02-20%20192850.png)
![image](assets/Screenshot%202022-02-20%20192726.png)

### 多级反馈队列调试算法

![image](assets/Screenshot%202022-02-20%20213220.png)

### 对比

|     算法     |        可抢占         |           优点            |            缺点             | 会导致饥饿吗 |              补充              |
| :----------: | :-------------------: | :-----------------------: | :-------------------------: | :----------: | :----------------------------: |
|  时间片轮转  |        抢占式         |    公平,适用于分时系统    | 频繁切换有开销,不区分优先级 |     不会     | 时间片太小或太大会有不同的变化 |
|  优先级调试  | 有抢占式,有也非抢占式 | 区分优先级,适用于实时系统 |        可能导致饥饿         |      会      |        动态/静态优先级         |
| 多级反馈队列 |        抢占式         |         平衡优秀          |         可能会饥饿          |      会      |                                |

注:比起早期的批处理操作系统来说,由于计算机造价大幅降低,因此之后出现的交互式操作系统(包括分时操作系统,实时操作系统等)更注意系统的响应时间,公平性,平衡性等指标.而这几种算法恰好也能较好地满足交互式系统的需求.因此这三种算法适合用于交互式系统.(比如UNIX使用的就是多级反馈队列调试算法)

## 进程同步

> 同步亦称直接制约关系,它是指为完成某种任务而建立的两个或多个进程,这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系.进程间的直接制约关系就是源于它们之间的相互合作.

## 进程互斥

> 我们把一个时间段内只允许一个进程使用的资源称为临界资源.许多物理设备(比如摄像头,打印机)都属于临界资源.此外还有许多变量,数据,内存缓冲区等都属于临界资源.  
> 对临界资源的访问,必须互斥地进程.互斥,亦称间接制约关系.进程互斥指当一个进程访问某临界资源时,另一个想要访问该临界资源的进程必须等待.当前访问临界资源的进程访问结束,释放该资源之后,另一个进程才能访问临界资源.

![image](assets/Screenshot%202022-02-21%20194938.png)
为了实现对临界资源的互斥访问,同时保证系统整体性能,需要遵循以下原则:

1. 空闲让进.临界区空闲时,可以允许一个请求进入临界区的进程立即进入临界区.
2. 忙则等待.当已有进程进入临界区时,其他试图进入临界区的进程必须等待.
3. 有限等待.对请求访问的进程,应保证能在有限时间内进入临界区(保证不会饥饿).
4. 让权等待.当进程不能进入临界区时,应当即释放处理机,防止进程忙等待.

### 小结

![image](assets/Screenshot%202022-02-21%20195622.png)

## 进程互斥的软件实现方法

### 单标志法

> 算法思想:两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程.也就是说每个进程进入临界区的权限只能被另一个进程赋予

![image](assets/Screenshot%202022-02-23%20175755.png)

### 双标志先检查法

> 算法思想:设置一个布尔型数组flag[image],数组中各个元素用来标记各进程想进入临界区的意愿,比如
>
> ```c
> flag[0] = false;
> ```
>
> 意味着0号进程P0现在想要进入临界区.每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区,如果没有,则把自身对应的标志`flag[i]`设为`true`,之后开始访问临界区.

![image](assets/Screenshot%202022-02-24%20203107.png)

### 双标志后检查法

> 算法思想:双标志先检查法的改版.前一个算法的问题是先"检查"后"上锁",但是这两个操作又无法一气可成,因此导致了两个进程同时进入临界区的问题.因此,人们又想到先"上锁"后"检查"的方法,来避免上述问题.

![image](assets/Screenshot%202022-02-24%20203817.png)

### Peterson 算法

> 算法思想:双标志后检查法中,两个进程都争着想进入临界区,但是谁也不让谁,最后谁都无法进入临界区.Gary L. Peterson 想到了一种方法,如果双方都争着想进入临界区,那可以让进程尝试"孔融让梨",主动让对方先使用临界区.

![image](assets/Screenshot%202022-02-26%20101210.png)
Peterson 算法用软件方法解决了进程互斥问题,遵循了空闲让进,忙则等待,有限等待三个原则,但是依然未遵循让权等待的原则.

### 小结

![image](assets/Screenshot%202022-02-26%20102111.png)

## 进程互斥的硬件实现方法

### 中断屏蔽方法

> 利用"开/关中断指令"实现(与原语的实现思想相同,即在某进程开始访问临界区到结束访问为止都不允许被中断,也就不能发生进程切换,因此也不可能发生两个同时访问临界区的情况)

![image](assets/Screenshot%202022-02-27%20200248.png)

### TestAndSet指令

> 简称TS指令,也有地方称为TestAndSetLock指令,或TSL指令.  
> TSL指令是用硬件实现的,执行的过程不允许补中断,只能一气呵成.以下是用C语言描述的**逻辑**(只能逻辑,因为这是要用硬件实现的)

![image](assets/Screenshot%202022-02-27%20201641.png)

### Swap指令

> 有的地方也叫Exchange指令,或简称ECHG指令.
> Swap指令是用硬件实现的,执行的过程不允许被中断,只能一气呵成.以下是用C语言描述的逻辑

![image](assets/Screenshot%202022-02-27%20203118.png)

### 小结

![image](assets/Screenshot%202022-02-27%20203221.png)

## 信号量机制

> 用户进程可以通过使用操作系统提供的一个对原语来对信号量进行操作,从而很方便的实现了进程互斥,进程同步.  
> 信号量其实就是一个变量(可以是一个整数,也可以是更复杂的记录型变量),可以用一个信号量来表示系统中某种资源的数量,比如:系统中只有一台打印机,就可以设置一个初值为1的信号量.  
> 原语是一种特殊的程序段,其执行只能一气呵成,不可被中断.原语是由关中断/开中断指令实现的,软件解决方案的主要问题是由"进入区的各种操作无法一气呵成0",因此如果能把进入区,退出区的操作都用"原语"实现,使这些操作能"一气呵成"就能避免问题.  
> 一对原语: `wait(S)`原语和`signal(S)`原语,可以把原语理解为我们自己写的函数,函数名分别为wait和signal,括号里的信号量S其实就是函数调用时传入的一个参数.  
> wait,signal原语常简称为P,V操作(来处荷兰语proberen和verhogen).因此,常把`wait(S)`和`signal(S)`两个操作分别写为`P(S)`和`V(S)`.

### 整型信号量

![image](assets/Screenshot%202022-03-03%20202259.png)

### 记录型信号量

![image](assets/Screenshot%202022-03-03%20204027.png)
![image](assets/Screenshot%202022-03-03%20205757.png)

### 小结

![image](assets/Screenshot%202022-03-03%20210015.png)

## 用信号量机制实现进程互斥,同步,前驱关系

### 进程互斥

![image](assets/Screenshot%202022-03-05%20123628.png)

### 进程同步

![image](assets/Screenshot%202022-03-05%20123902.png)
![image](assets/Screenshot%202022-03-05%20154601.png)

### 实现前驱关系

![image](assets/Screenshot%202022-03-05%20162207.png)

### 小结

![image](assets/Screenshot%202022-03-05%20162707.png)

## 生产者-消费者问题

系统中有一组生产者进程和一组消费者进程,生产者进程每次生产一个产品放入缓冲区,消费者进程每次从缓冲区中取出一个产品并使用.(注:这里的"产品"理解为某种数据)  
生产者,消费者共享一个初始为空,大小为n的缓冲区.  
只有缓冲区没满时,生产者才能把产品放入缓冲区,否则必须等待.  
只有缓冲区没空时,消费者才能从中取出产品,否则必须等待.  
缓冲区是临界资源,各进程必须互斥地访问.

### 实现

![image](assets/Screenshot%202022-03-05%20173032.png)

## 多生产者-多消费者问题

桌子上有一个盘子,每次只能向其中放入一个水果.爸爸专向盘子中放苹果,妈妈专向盘子中放橘子,儿子专等着吃盘子中的橘子,女儿专等着吃盘子中的苹果.只有盘子空时,爸爸或妈妈才可向盘子中放一个水果.仅当盘子中有自己需要的水果时,儿子或女儿可以从盘子中取出水果.

### 实现

![image](assets/Screenshot%202022-03-05%20211509.png)

## 吸烟者问题

假设一个系统有三个抽烟者进程和一个供应者进程.每个抽烟者不停地卷烟并抽掉它,但是要卷起并抽掉一支烟,抽烟者需要有三种材料:烟草,纸和胶水.三个抽烟者中,第一个拥有烟草,第二个拥有纸,第三个拥有胶水.供应者进程无限地提供三种材料,供应者每次将两种材料放桌子上,拥有剩下那种材料的抽烟者卷一根烟并抽掉它,并给供应者一个信号告诉完成了,供应者就会放另外两种材料在桌子上,这个过程一重复(让三个抽烟者轮流地抽烟)

### 实现

![image](assets/Screenshot%202022-03-05%20225408.png)

## 读者-写者问题

有读者和写者两组并发进程,共享一个文件,当两个或两个以上的读进程同时访问共享数据时不会产生副作用,但若某个写进程和其他进程(读进程或写进程)同时访问共享数据可能导致数据不一致的错误.因此要求:

1. 允许多个读者可以同时对文件执行读操作
2. 只允许一个写者往文件中写信息
3. 任一写者在完成写操作之前不允许其他读者或写者工作
4. 写者执行操作前,应让已有读者和写者全部退出.

### 读者优先

![image](assets/Screenshot%202022-03-06%20125145.png)

### 写者优先

![image](assets/Screenshot%202022-03-06%20125853.png)

## 哲学家进餐问题

一张圆桌上坐着5名哲学家,每两个哲学家之间的桌上摆一根筷子,桌子的中间是一碗米饭.哲学家们倾注毕生的精力用于思考和进餐,哲学家在思考,并不影响他人.只有哲学家饥饿时,才试图拿起左,右两根筷子(一根一根地拿起).如果筷子已在他人手上,则需等待.饥饿的哲学家只有同时拿起两根筷子才可以开始进餐,当进餐完毕后,放下筷子继续思考.

### 实现方案

![image](assets/Screenshot%202022-03-06%20184640.png)
![image](assets/Screenshot%202022-03-06%20185313.png)

## 管程

管程是一种特殊的软件模块,有这些部分组成:

1. 局部于管程的共享数据结构说明
2. 对该数据结构进行操作的一组过程
3. 对局部于管程的共享数据设置初始值的语句
4. 管程有一个名字

管程的基本特征:

1. 局部于管程的数据只能被局部于管程的过程所访问
2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
3. 每次仅允许一个进程在管程内执行某个内部过程

### 用管程解决生产者消费者问题

![image](assets/Screenshot%202022-03-07%20000718.png)
![image](assets/Screenshot%202022-03-07%20001057.png)

### Java中类似于管程的机制

![image](assets/Screenshot%202022-03-07%20001629.png)

### 小结

![image](assets/Screenshot%202022-03-07%20001851.png)

## 死锁

在并发环境下,各进程因竞争资源而造成的一种互相等待对方手里的资源,导致各进程都阻塞,都无法向前推进的现象,就是"死锁".发生死锁后,若无外力干涉,这些进程都将无法向前推进.

### 死锁,饥饿,死循环的区别

+ 死锁:各进程互相等待对方手里的资源,导致各进程都阻塞,无法向前推进的现象.
+ 饥饿:由于长期得不到想要的资源,某进程无法向前推进的现象.比如,在短进程优先(SPF)算法中,若有源源不断的短进程到来,则长进程将一直得不到处理机,从而发生长进程"饥饿".
+ 死循环:某进程执行过程中一直跳不出某个循环的现象.有时是因为程序逻辑bug导致的,有时是程序员故意设计的.

![image](assets/Screenshot%202022-03-10%20202832.png)

### 死锁产生的必要条件

产生死锁必须同时满足以下四个条件,只要其中任一条件不成立,死锁就不会发生.

1. 互斥条件:只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子,打印机设备).像内存,扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源).
2. 不剥夺条件:进程所获得的资源在未使用完之前,不能由其他进程强行夺走,只能主支释放.
3. 请求和保持条件:进程已经保持了至少一个资源,但又提出了新的资源请求,而该资源又被其他进程占有,此时请求进程被阻塞,但又对自己已有的资源保持不放.
4. 循环等待条件:存在一种进程资源的循环等待链,链中的每一个进程已获得的资源同时被下一个进程所请求.

注意!发生死锁时一定有循环等待,但是发生循环等待时未必死锁(循环等待是死锁的必要不充分条件).因为如果同类资源数大于1,则即使有循环等待,也未必发生死锁.但如果系统中每类资源都只有一个,那循环等待就是死锁的充分必要条件了.

### 什么时候会发生死锁

1. 对系统资源的竞争.各进程对不可剥夺的资源(如打印机)的竞争可能引起死锁,对可剥夺的资源(CPU)的竞争是不会引起死锁的.
2. 进程推进顺序非法.请求和释放资源的顺序不当,也同样会导致死锁.例如,并发执行的进程P1,P2分别申请并占有了资源R1,R2,之后进程P1又紧接着申请资源R2,而进程P2又申请资源R1,两者会因为申请的资源被对方占有而阻塞,从而发生死锁.
3. 信号量的使用不当也会造成死锁.如生产者-消费者问题中,如果实现互斥的P操作在实现同步的P操作之前,就有可能导致死锁.(可以把互斥信号量,同步信号量也看做是一种抽象的系统资源).

总之,对不可剥夺资源的不合理分配,可能导致死锁.

### 死锁的处理策略

1. 预防死锁:破坏死锁产生的四个必要条件中的一个或几个.
2. 避免死锁:用某种方法防止系统进入不安全状态,从而避免死锁(银行家算法)
3. 死锁的检测和解除.允许死锁的发生,不过操作系统会负责检测出死锁的发生,然后采取某种措施解除死锁.

### 小结

![image](assets/Screenshot%202022-03-10%20211801.png)

## 预防死锁

### 破坏互斥条件

互斥条件:只有对必须互斥使用的资源的争抢才会导致死锁

如果把只能互斥使用的资源改造为允许共享使用,则系统不会进入死锁状态.比如:SPOOLing技术.  
操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备.
![image](assets/Screenshot%202022-03-13%20191351.png)
该策略的缺点:并不是所有的资源都可以改造成可共享使用的资源.并且为了系统安全,很多地方还必须保护这种互斥性.因此,很多时候都无法破坏互斥条件.

### 破坏不剥夺条件

不剥夺条件:进程所获得的资源在未使用完之前,不能由其他进程强行夺走,只能主动释放.

破坏不剥夺条件:  
方案一: 当某个进程请求新的资源得不到满足时,它必须立即释放保持的所有资源,待以后需要时再重新申请.也就是说,即使某些资源尚未使用完,也需要主动释放,从而破坏了不可剥夺条件.  
方案二: 当某个进程需要的资源被其他进程所占有的时候,可以由操作系统协助,将想要的资源强行剥夺.这种方式一般需要考虑各进程的优先级(比如:剥夺调试方式,就是将处理机资源强行剥夺给优先级更高的进程使用)

该策略的缺点:

1. 实现起来比较复杂
2. 释放已获得的资源可能造成前一阶段工作的失效.因此这种方法一般只适用于易保存和恢复状态的资源,如CPU
3. 反复地申请和释放资源会增加系统开销,降低系统吞吐量
4. 若采用方案一,意味着只要暂时得不到某个资源,之前获得的那些资源就都需要放弃,以后再重新申请.如果一直发生这样的情况,就会导致进程饥饿

### 破坏请求和保持条件

请求和保持条件:进程已经保持了至少一个资源,但又提出了新的资源请求,而该资源又被其他进程占有,此时请求进程被阻塞,但又对自己已有的资源保持不放.

可以采用静态分配方法,即进程在运行前一次申请完它所需要的全部资源,在它的资源未满足前,不让投入运行.一旦投入运行后,这些资源就一直归它所有,该进程就不会再请求别的任何资源了.

该策略实现起来简单,但也有明显的缺点:  
有些资源可能只需要用很短的时间,因此如果进程的整个运行期间都一直保持着所有资源,就会造成严重的资源浪费,资源利用率极低.另外,该策略也有可能导致某些进程饥饿.

### 破坏循环等待条件

循环等待条件:存在一种进程资源的循环等待链链中的每一个进程已获得的资源同时被下一个进程所请求.

可采用顺序资源分配法.首先给系统中的资源编号,规定每个进程必须按编号递增的顺序请求资源,同类资源(即编号相同的资源)一次申请完.

原理分析:一个进程只有已占有小编号的资源时,才有资格申请更大编号的资源.按此规则,已持有大编号资源的进程不可能逆向地回来申请小编号的资源,从而就不会产生循环等待的现象

![image](assets/Screenshot%202022-03-13%20200334.png)

### 小结

![image](assets/Screenshot%202022-03-13%20201102.png)

## 避免死锁

### 安全序列

所谓安全序列,就是指如果系统按照这种序列分配资源,则每个进程都能顺利完成.只要能找出一个安全序列,系统就是安全状态.当然,安全序列可能有多个.  
如果分配了资源之后,系统中找不出任何一个安全序列,系统就进入了不安全状态.这就意味着之后可能所有进程都无法顺利的执行下去.当然,如果有进程提前归还了一些资源,那系统也有可能重新回到安全状态,不过我们在分配资源之前总是要考虑到最坏的情况.  
如果系统处于安全状态,就一定不会发生死锁.如果系统进入不安全状态,就可能发生死锁(处于不安全状态未必就发生了死锁,但发生了死锁时一定是在不安全状态)  
因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态,以此决定是否答应资源分配请求.这也是"银行家算法"的核心思想.

### 银行家算法

银行家算法是荷兰学者Dijkstra为银行系统设计的,以确保银行在发放现金贷款时,不会发后不能满足所有客户需要的情况.后来该算法被用在操作系统中,用于避免死锁.  
核心思想:在进程提出资源申请时,先预判此次分配是否会导致系统进入不安全状态.如果会进入不安全状态,就暂时不答应这次请求,让该进入先阻塞等待.
![image](assets/Screenshot%202022-03-14%20193759.png)
![image](assets/Screenshot%202022-03-14%20194042.png)

## 死锁的检测和解除

为了能对系统是否已发生了死锁进行检测,必须:

1. 用某种数据结构来保存资源的语法和分配信息
2. 提供一种算法,利用上述信息来检测系统是否已进入死锁状态

![image](assets/Screenshot%202022-03-20%20144940.png)
![image](assets/Screenshot%202022-03-20%20151453.png)

### 算法

![image](assets/Screenshot%202022-03-22%20212323.png)

### 死锁的解除

![image](assets/Screenshot%202022-03-22%20212853.png)

### 小结

![image](assets/Screenshot%202022-03-22%20213039.png)

## 内存基础

### 绝对装入

在编译时,如果知道程序将放到内存中的哪个位置,编译程序将产生绝对地址的目标代码.装入程序按照装入模块中的地址,将程序和数据装入内存.  
绝对装入只适用于单道程序环境.  
程序中使用的绝对地址,可在编译或汇编时给出,也可由程序员直接赋予.通常情况下都是编译或汇编时再转换为绝对地址.

### 静态重定位

又称可重定位装入.编译,链接后的装入模块的地址都是从0开始的,指令中使用的地址,数据存放地址都是相对于起始地址而言的逻辑地址.可根据内存的当前情况,将装入模块装入到内存的适当位置.装入是对地址进行"重定位",将逻辑地址变换为物理地址(地址变换是在装入时一次完成的).  
静态重定位的特点是在一个作业装入内存时,必须分配其要求的全部内存空间,如果没有足够的内存,就不能装入该作业.作业一旦进入内存后,在运行期间就不能再移动,也不能再申请内存空间.

### 动态重定位

又称动态运行时装入.编译,链接后的装入模块的地址都是从0开始的.装入程序把装入模块装入内存后,并不会立即把逻辑地址转换为物理地址,而是把地址转换推迟到程序真正要执行时才进行.因此装入内存后所有的地址依然是逻辑地址.这种方式需要一个重定位寄存器的支持.  
采用动态重定位时允许程序在内存中发生移动.  
并且可将程序分配到不连续的存储区中;在程序运行前中需装入它的部分代码即可投入运行,然后在程序运行期间,根据需要动态申请分配内存;便于程序段的共享,可以向用户提供一个比存储空间大得多的地址空间.

### 链接的三种方式

![image](assets/Screenshot%202022-03-23%20205443.png)

### 小结

![image](assets/Screenshot%202022-03-23%20205809.png)

## 内存管理

1. 操作系统负责内存空间的分配与回收
2. 操作系统需要提供某种技术从逻辑上对内存空间进行扩充
3. 操作系统需要提供地址转换功能,负责程序的逻辑地址与物理地址的转换
4. 操作系统需要提供内存保护功能.保证各进程在各自存储空间内运行,互不干扰
   + 方案一,在CPU中设置一对上,下限寄存器,存放进程的上,下限地址.进程的指令要访问某个地址时,CPU检查是否越界
   + 方案二,采用重定位寄存器(又称基址寄存器)和界地址寄存器(又称限长寄存器)进行越界检查.重定位寄存器中存放的是进程的起始物理地址.界地址寄存器中存放的是进程的最大逻辑地址

### 小结

![image](assets/Screenshot%202022-03-24%20193648.png)

## 覆盖与交换

### 覆盖技术

将程序分为多个段(多个模块).常用的段常驻内存,不常用的段在需要时调入内存.  
内存中分类一个"固定区"和若干个"覆盖区".  
需要常驻内存的段放在"固定区"中,调入后就不再调出(除非运行结束)  
不常用的段放在"覆盖区",需要用到时调入内存,用不到时调出内存
![image](assets/Screenshot%202022-03-28%20202743.png)

### 交换技术

内存空间紧张时,系统将内存中某些进程暂时换出外存,把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调试)
![image](assets/Screenshot%202022-03-28%20210416.png)
![image](assets/Screenshot%202022-03-28%20211112.png)

### 小结

![image](assets/Screenshot%202022-03-28%20211325.png)

## 连续分配管理方式

### 单一连续分配

![image](assets/Screenshot%202022-04-18%20200004.png)

### 固定分区分配

![image](assets/Screenshot%202022-04-18%20200502.png)
![image](assets/Screenshot%202022-04-19%20211448.png)

### 动态分区分配

动态分区分配又称为可变分区分配.这种分配方式不会预先划分内存分区,而是在进程装入内存时,根据进程的大小动态地建立分区,并使分区的大小正好适合进程的需要.因此系统分区的大小和数目是可变的.
![image](assets/Screenshot%202022-04-20%20185438.png)
![image](assets/Screenshot%202022-04-20%20185608.png)
还有就是如何分配与回收,分配是从低地址分,还是按大小最匹配方式分.  
回收就是,回收的空间如何与原空闲空间合并.

+ 内部碎片:分配给某进程的内存区域中,那些没有用上的部分.
+ 外部碎片:是指内存中的某些空间分区由于太小而难以利用.

动态分区分配没有内部碎片,但是有外部碎片.

如果内存中空闲空间的总和本来可以满足某些进程的要求,但由于进程需要的是一整块连续的内存空间,因此这些"碎片"不能满足进程的需求.  
可以通过紧凑(拼凑,Compaction)技术来解决外部碎片.

### 小结

![image](assets/Screenshot%202022-04-22%20212301.png)

## 动态分区分配算法

### 首次适应算法

算法思想:每次都从低地址开始查找,找到一个能满足大小的空闲分区.  
如何实现:空闲分区以地址递增的次序排列.每次分配内存时顺序查找空闲分区链(或空闲分区表),找到大小能满足要求的第一个空闲分区.
![image](assets/Screenshot%202022-05-05%20191118.png)

### 最佳适应算法

算法思想:由于动态分区分配是一种连续分配方式,为各进程分配的空间必须是连续的一整片区域.因此为了保证当"大进程"到来时能有连续的大片空间,可以尽可能多地留下大片的空闲区,即,优先使用更小的空闲区.  
如何实现:空闲分区按容量递增次序连接.每次分配内存时顺序查找空闲分区链(或空闲分区表),找到大小能满足要求的第一个空闲分区.
![image](assets/Screenshot%202022-05-05%20191916.png)
缺点:每次都选最小的分区进行分配,会留下越来越多的,很小的,难以利用的内存块.因此这种方法会产生很多的外部碎片.

### 最坏适应算法

又称最大适应算法(Largest Fit)  
算法思想:为了解决最佳适应算法的问题--即留下太多难以利用的小碎片,可以在每次分配时,优先使用最大的连续空闲区,这样分配后剩余的空闲区就不会太小,更方便使用.  
如何实现:空闲分区按容量递减次序链接.每次分配内存时顺序查找空闲分区连(或空闲分区表),找到大小能满足要求的第一个空闲分区.
![image](assets/Screenshot%202022-05-05%20192749.png)
缺点:每次都选最大的分区进行分配,虽然可以让分配后留下的空闲区更大,更可用,但是这种方式会导致较大的连续空闲区被迅速用完.如果之后有"大进程"到达,就没有内存分区可用了.

### 邻近适应算法

算法思想:首次适应算法每次都从链头开始查找的.这可能会导致低地址部分出现很多小的空闲分区,而每次分配查找时,都要经过这些分区,因此也增加了查找的开销.如果每次都从上次查找结束的位置开始检索,就能解决上述问题.  
如何实现:空闲分区以地址递增的顺序排列(可排成一个循环链表).每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表),找到大小能满足要求的第一个空闲分区.
![image](assets/Screenshot%202022-05-05%20194526.png)

### 对比

![image](assets/Screenshot%202022-05-05%20194848.png)

## 基本分布存储管理的基本概念

![image](assets/Screenshot%202022-05-09%20185620.png)

### 逻辑地址结构

![image](assets/Screenshot%202022-05-24%20233109.png)

### 页表

![image](assets/Screenshot%202022-05-24%20233954.png)
![image](assets/Screenshot%202022-05-24%20234344.png)

### 小结

![image](assets/Screenshot%202022-05-24%20234922.png)

## 基本地址变换机构

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址.  
通常会在系统中设置一个页表寄存器(PTR),存放页表在内存中的起始地址F和页表长度M.进程未执行时,页表的始址和页表长度放在进程控制块(PCB)中,当进程被调试时,操作系统内核会把他们放到页表寄存器中.  
注意:页面大小是2的整数幂  
设页面大小为L,逻辑地址A到物理地址E的变换过程如下:

1. 计算页号P和页内偏移量W(如果用十进程数手算,则P=A/L,W=A%L;但是在计算机实际运行时,逻辑地址结构是固定不变的,因此计算机硬件可以更快地得到二进制表示的页号,页内偏移量)
2. 比较页号P和页表长度M,若P>=M,则产生越界中断,否则继续执行.(注意:页号是从0,而页表长至少是1,因此P=M时也会越界)
3. 页表中页号P对应的页表项地址=页表起始地址F+页号P*页表长度,取出该页表项内容b,即为内存块号.(注意区分页表项长度,页表长度,页面大小的区别.页表长度指的是这个页表中总共有几个页;页表项长度指的是每个页表占多大的存储空间;页面大小指的是一个页面占多大的存储空间)
4. 计算E=b*L+W,用得到的物理地址E去访存.(如果内存块号,页面偏移量是用二进制表示的,那么把二者拼接起来就是最终的物理地址了)

### 小结

![image](assets/Screenshot%202022-05-28%20112710.png)

## 具有快表的地址变换机构

+ 时间局部性:如果执行了程序中的某条指令,那么不久后这条指令很有可能再次执行;如果某个数据被访问过,不久之后该数据很可能再次被访问.(因为程序中存在大量的循环)
+ 空间局部性:一旦程序访问了某个存储单元,在不久之后,其附近的存储单元也很有可能被访问.(因为很多数据在内存中都是连续存放的)

### 快表

又称联想寄存器(TLB),是一种访问速度比内存快很多的高速缓冲存储器,用来存放当前访问的若干表项,以加速地址变换的过程.与此对应,内存中的页表常称为慢表.  

1. CUP给出逻辑地址,由某个硬件算得页号,页内偏移量,将页号与快表的所有页号进行比较.
2. 如果找到匹配的页号,说明要访问的页项在快表中有副本,则直接从中取出该页对应的内存块号,再将内存块号与页内偏移量拼接形成物理地址,最后,访问该物理地址对应的内存单元.因此,若快表命中,则访问某个逻辑地址仅需一次访存即可.
3. 如果没有找到匹配的页号,则需要访问内存中的页表,找到对应页表项,得到页面存放的内存块号,再将内存块号与页内偏移量拼接形成物理地址,最后,访问该物理地址对应的内存单元.因此,若快表未命中,则访问某个逻辑地址需要两次访存(注意:在找到页表项后,应同时将其存入快表,以便后面可能的再次访问.但若快表已满,则必须按照一定的算法对旧的页表项进行替换)

由于查询快表的速度比查询页表的速度快很多,因此只要快表命中,就可以节省很多时间.  
因为局部性原理,一般来说快表的命中率可以达到90%以上.

### 小结

|                        |                                                                                                                   地址变换过程                                                                                                                   |             访问一个逻辑地址的访存资料             |
| :--------------------: | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | :------------------------------------------------: |
|    基本地址变换机构    |                                                 1. 算页号,页内偏移量<br>2. 检查页号合法性<br>3. 查页表,找到页面存放的内存块号<br>4. 根据内存块号与页内偏移量得到物理地址<br>5. 访问目标内存单元                                                  |                      两次访存                      |
| 具有快表的地址变换机构 | . 算页号,页内偏移量<br>2. 检查页号合法性<br>3. 查快表.若命中,即可知道页面存放的内存块,可直接进行5;若未命中则进行4<br>4. 查页表,找到页面存放的内存块号,并且将页表项复制到快表中<br>5. 根据内存块号与页内偏移量得到物理地址<br>6. 访问目标内存单元 | 快表命中,只需一次访存<br />快表未命中,需要两次访存 |

## 两级页表

可将长长的页表进行分组,使每个内存块刚好可以放入一个分组(比如上个例子中,页面大小4KB,每个页表项4B,因此每1K个连续的页表项为一组,每组刚好点一个内存块,再将各组离散地放到各个内存块中).  
另外,要为离散分配的页表再建立一张页表,称为页目录表,或称外层页表,或称顶层页表.

### 细节

1. 若采用多级页表机制,则各级页表的大小不能超过一个页面
2. 两级页表的访存次数比一级页表多了一次(没有使用快表机构)

### 小结

![image](assets/Screenshot%202022-05-29%20045323.png)

## 基本分段存储管理方式

### 分段

进程的地址空间:按照程序自身的逻辑关系划分为若干个段,每个段都有一个段名(在低级语言中,程序员使用段名来编程),每段从0开始编址  
内存分配规则:以段为单位进行分配,每个段在内存中占据连续空间,但各段之间可以不相邻.
![image](assets/Screenshot%202022-05-29%20092420.png)
![image](assets/Screenshot%202022-05-29%20093257.png)

### 段表

程序分多个段,各段离散地装入内存,为了保证程序能正常运行,就必须能从物理内存中找到各个逻辑的存放位置.为此,需为每个进程建立一张段映射表,简称"段表".
![image](assets/Screenshot%202022-05-29%20094857.png)

### 地址变换

![image](assets/Screenshot%202022-05-29%20100641.png)

### 分段,分页管理的对比

页是信息的物理单位.分页的主要目的是为了实现离散分配,提高内存利用率.分页仅仅是系统管理上的需要,完全是系统行为,对用户是不可见的.  
段是信息的逻辑单位.分段的主要目的是更好地满足用户需求.一个段通常包含着一组属于一个逻辑模块的信息.分段对用户是可见的,用户编程时需要显式地给出段名.  
页的大小固定且由系统决定.段的长度却不固定,决定于用户编写的程序.  
分布的用户进程地址空间是一维的,程序员中需给出一个记忆符即可表示一个地址.  
分段的用户进程地址空间是二维的,程序员在标识一个地址时,既要给出段名,也要给出段内地址.
![image](assets/Screenshot%202022-05-29%20103028.png)
![image](assets/Screenshot%202022-05-29%20103405.png)
![image](assets/Screenshot%202022-05-29%20103640.png)

### 小结

![image](assets/Screenshot%202022-05-29%20105523.png)

## 段页式管理方式

### 分页,分段的优缺点分析

|          |                          优点                          |                                   缺点                                    |
| :------: | :----------------------------------------------------: | :-----------------------------------------------------------------------: |
| 分页管理 | 内存空间利用率高,不会产生外部碎片,只会有少量的页内碎片 |                   不方便按照逻辑块实现信息的共享和保护                    |
| 分段管理 |         很方便按照逻辑模块实现信息的共享和保护         | 如果段长过大,为其分配很大的连续空间会很不方便.另外,段式管理会产生外部碎片 |

### 分段+分页=段页式管理

![image](assets/Screenshot%202022-05-29%20165418.png)

### 段页工管理的逻辑地址结构

![image](assets/Screenshot%202022-05-29%20171035.png)
![image](assets/Screenshot%202022-05-29%20173837.png)
![image](assets/Screenshot%202022-05-29%20191638.png)

### 小结

![image](assets/Screenshot%202022-05-29%20192114.png)

## 虚拟内存的基本概念

### 传统存储管理方式的特征,缺点

![image](assets/Screenshot%202022-05-29%20200028.png)

### 虚拟内存的定义和特征

基本局部性原理,在程序装入时,可以将程序中很快会用到的部分装入内存,暂时用不到的部分留在丰存,就可以让程序开始执行.  
在程序执行过程中,当所访问的信息不在内存时,由操作系统负责将所需信息从外存调入内存,然后继续执行程序.  
若内存空间不够,由操作系统负责将内存中暂时用不到的信息换出到外存.  
在操作系统的管理下,在用户看来似乎有一个比实际内存大得多的内存,这就是虚拟内存(操作系统虚拟性的一个体现,实际的物理内存大小没有变,只是在逻辑上进行了扩充).  
虚拟内存的最大容量是由计算机的地址结构(CPU寻址范围)确定的.  
虚拟内存的实际容量=min(内存和外存容量之和,CPU寻址范围)

虚拟内存有以下三个主要特征:

+ 多次性:无需在作业运行时一次性全部装入内存,而是允许被分成多次调入内存.
+ 对换性:在作业运行时无需一直常驻内存,而是允许在作业运行过程中,将作业换入,换出.
+ 虚拟性:从逻辑上扩充了内存的容量,使用户看到的内存容量,远大于实际的容量.

### 如何实现虚拟内存技术

虚拟内存技术,允许一个作业分多次调入内存.如果采用连续分配方式,会不方便实现.因此,虚拟内存的实现需要建立在离散分配的内存管理方式基础上.

### 小结

![image](assets/Screenshot%202022-05-29%20215506.png)

## 请求分布管理方式

### 页表机制

![image](assets/Screenshot%202022-05-30%20185301.png)

### 缺页中断机构

![image](assets/Screenshot%202022-05-30%20185812.png)
缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的,因此属于内中断.  
一条指令在执行期间,可能和生多次缺页中断.(如:copy A to B , 即将逻辑地址A中的数据复制到逻辑地址B,而A,B属于不同的页面,则有可能产生两次中断)
![image](assets/Screenshot%202022-05-30%20190446.png)

### 地址变换机构

![image](assets/Screenshot%202022-05-30%20191849.png)
![image](assets/Screenshot%202022-05-30%20192214.png)

### 小结

![image](assets/Screenshot%202022-05-30%20193355.png)

## 页面转换算法

### 最佳转换算法(OPT)

最佳置换算法(OPT,Optimal):每次选择淘汰的页面将是以后永不使用,或者在最长时间内不再被访问的页面,这样可以保证最低的缺页率.但实际上,只有在进程执行的过程中才能知道接下来会访问到的是哪个页面.操作系统无法提前预判页面访问序列.因此,最佳转换算法是无法实现的.

### 先进先出置换算法(FIFO)

先进先出转换算法(FIFO):每次选择淘汰的页面是最早进入内存的页面  
实现方法:把调入内存的页面根据调入的先后顺序排成一个队列,需要换出页面时选择队头页面即可.  
队列的最大长度取决于系统为进程分配了多少个内存块.  
Belady异常:当为进程分配的物理块数增大时,缺页次数不减反增的异常现象.  
只有FIFO算法会和生Belady异常.另外,FIFO算法虽然实现简单,但是该算法与进程实际运行时的规律不适应,因为先进入的页面也有可能最经常被访问.因此,算法性能差.

### 最近最久未使用转换算法(LRU)

最近最久未使用转换算法(LRU,least recently used):每次淘汰的页面是最近最久未使用的页面  
实现方法:赋予每个页面对应的页表项中,用访问字段记录该页面自上次被访问以来所经历的时间t.当需要淘汰一个页面时,选择现有页面中t值最大的,即最近最久未使用的页面.  
缺点:该算法的实现需要专门的硬件支持,虽然算法性能好,但是实现困难,开销大.

### 时钟转换算法(CLOCK)

最佳置换算法性能最好,但无法实现;先进先出置换算法实现简单,但算法性能差;最近最久未使用置换算法性能好,是最接近OPT算法性能的,但是实现起来需要专门的硬件支持,算法开销大.  
时钟置换算法是一种性能和开销较均衡的算法,又称CLOCK算法,或最近未用算法(NRU,Not Recently Used)

+ 简单的CLOCK算法实现方法:

  为每个页面设置一个访问位,再将内存中的页面都通过链接指针链接成一个循环队列.当某页被访问时,其访问位置为1.当需要淘汰一个页面时,只需检查页的访问位.如果是0,就选择该页换出;如果是1,则将它置为0,暂不换出,继续检查下一个页面,若第一轮扫描中所有页面都是1,则将这些页面的访问位依次置为0后,再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面,因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描)
+ 改进型的时钟转换算法:

  简单的时钟置换算法仅考虑到一个页面最近是否被访问过.事实上,如果被淘汰的页面没有被修改过,就不需要执行I/O操作写回外存.只有被淘汰的页面被修改过时,才需要写回外存.  
  因此除了考虑一个页面最近有没有被访问过之外,操作系统还应考虑页面有没有被修改过.在其他条件都相同时,应优先淘汰没有修改过的页面,避免I/O操作.这就是改进型的时钟转换算法的思想.修改位=0,表示页面没有被修改过;修改位=1,表示页面被修改过.为方便讨论,用(访问位,修改位)的形式表示各页面状态.如(1,1)表示一个页面近期被访问过,且被修改过.  
  算法规则:将所有可能被转换的页面排成一个循环队列.  
  第一轮:从当前位置开始扫描到第一个(0,0)的帧用于替换.本轮扫描不修改任何标志位.  
  第二轮:若第一轮扫描失败,则重新扫描,查找第一个(0,1)的帧用于替换.本轮将所有扫描过的帧访问位设为0.  
  第三轮:若第二轮扫描失败,则重新扫描,查找第一个(0,0)的帧用于替换.本轮扫描不修改任何标志位.  
  第四轮:若第三轮扫描失败,则重新扫描,查找第一个(0,1)的帧用于替换.  
  由于第二轮已将所有帧的访问位设为0,因此经过第三轮,第四轮扫描一定会有一个帧被选中,因此改进型CLOCK转换算法选择一个淘汰页面最多会进行四轮扫描.

### 对比

![image](assets/Screenshot%202022-06-04%20220256.png)

## 页面分配策略

### 页面分配,转换策略

驻留集:指请求分布存储管理中给进程分配的物理块的集合.  
在采用了虚拟存储技术的系统中,驻留集大小一般小于进程的总大小.  
若驻留集太小,会导致缺页频繁,系统要花大量的时间来处理缺页,实际用于进程推进的时间很少;  
驻留集太大,又会导致多道程序并发度下降,资源利用率降低.所以应该选择一个合适的驻留集大小.  
固定分配:操作系统为每个进程分配一组固定数目的物理块,在进程运行期间不再改变.即,驻留集大小不变  
可变分配:先为每个进程分配一定数目的物理块,在进程运行期间,可根据情况做适当的增加或减少.即,驻留集大小可变  
局部转换:发生缺页时只能选进程自己的物理块进行转换.  
全局转换:可以将操作系统保留的空闲物理块分配给缺页进程,也可以将别的进程持有的物理块置换到外存,再分配给缺页进程.

|          | 局部转换 | 全局转换 |
| :------: | :------: | :------: |
| 固定分配 |    V     |    X     |
| 可变分配 |    V     |    V     |

### 固定分配局部转换

系统为每个进程分配一定数量的物理块,在整个运行期间都不改变.若进程在运行中发生缺页,则只能从该进程在内存中的页面中选出一页换出,然后再调入需要的页面.这种策略的缺点是:很难在刚开始就确定应为每个进程分配多少个物理块才算合理.(采用这种策略的系统可以根据进程大小,优先级,或是根据程序员给出的参数来确定为一个进程分配的内存块数)

### 可变分配全局转换

刚开始会为每个进程分配一定数量的物理块.操作系统会保持一个空闲物理块队列.当某进程发生缺页时,从空闲物理块中取出一块分配给该进程;若已无空闲物理块,则可选择一个未锁定的(系统会锁定一些页面,这些页面中的内容不能转换出外存,如,重要的内核数据可以设为锁定)页面换出外存,再将该物理块分配给缺页的进程.采用这种策略时,只要某进程发生缺页,都将获得新的物理块,仅当空闲物理块用完时,系统才选择一个未锁定的页面调出.被选择调出的页可能是系统中任何一个进程中的页,因此这个被选中的进程拥有的物理块会减少,缺页率会增加.

### 可变分配局部转换

刚开始会为每个进程分配一定数量的物理块.当某进程发生缺页时,只允许从该进程自己的物理块中选出一个进行换出外存.如果进程在运行中频繁地缺页,系统会为该进程多分配几个物理块,直至该进程缺页率趋势适当程度;反之,如果进程在运行中缺页率特别低,则可适当减少分配给该进程的物理块.

### 何时调入页面

1. 预调页策略:根据局部性原理,一次调入若干个相邻的页面可能比一次调入一个页面更高效.但如果提前调入的页面中大多数都被访问过,则又是低效的.因此可以预测不久之后可能访问到的页面,将它们预先调入内存,但目前预测成功率只有50%左右.故这种策略主要用于进程的首次调入,由程序员指出应该先调入哪些部分.
2. 请求调页策略:进程在运行期间发现缺页时才将所缺页面调入内存.由 种策略调入的页面一定会被访问到,但由于每次只能调入一页,而每次调页都要磁盘I/O操作,因此I/O开销较大.

### 从何处调入页面

![image](assets/Screenshot%202022-06-06%20205044.png)

### 抖动(颠簸)现象

刚刚换出的页面马上又要换入内存,刚刚换入的页面马上又要换出外存,这种频繁的页面高度行为称为抖动,或颠簸.产生拉动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)

### 工作集

![image](assets/Screenshot%202022-06-06%20210952.png)

### 小结

![image](assets/Screenshot%202022-06-06%20211446.png)

## 初识文件管理

### 文件的属性

+ 文件名:由创建文件的用户决定文件名,主要是为了方便用户找到文件,同一目录下不允许有重名文件.
+ 标识符:一个系统内的各文件标识符唯一,对用户来说毫无可读性,因此标识符只是操作系统用于区分各个文件的一种内部名称.
+ 类型:指明文件的类型
+ 位置:文件存放的路径(让用户使用),在外存中的地址(操作系统使用,对用户不可见)
+ 大小:指明文件大小
+ 保护信息:对文件进行保护的访问控制信息
+ 创建时间,上次修改时间,文件所有者信息......

### 小结

![image](assets/Screenshot%202022-06-07%20200006.png)

## 文件的逻辑结构

### 无结构文件

文件内部的数据就是一系列二进制流或字符流组成.又称"流式文件".如,Windows 中的.txt文件  
无结构文件内部的数据其实就是一系列字符流,没有明显的结构特性.因此也不用探讨无结构文件的"逻辑结构"问题.

### 有结构文件

由一组相似的记录组成,又称"记录式文件".每条记录有若干个数据项组成.如:数据库表文件.一般来说,每条记录有一个数据项可作为关键字.根据各条记录的长度(占用的存储空间)是否相等,又可分为定长记录和可变长记录两种.

+ 顺序文件:文件中的记录一个接一个地顺序排列(逻辑上),记录可以是定长的或可变长的.各个记录在物理上可以顺序存储或链式存储![image](assets/Screenshot%202022-06-08%20192818.png)![image](assets/Screenshot%202022-06-08%20193645.png)
+ 索引文件:![image](assets/Screenshot%202022-06-08%20194107.png)
+ 索引顺序文件:![image](assets/Screenshot%202022-06-08%20222216.png)![image](assets/Screenshot%202022-06-08%20222449.png)
+ 多级索引顺序文件:![image](assets/Screenshot%202022-06-08%20222641.png)

### 小结

![image](assets/Screenshot%202022-06-08%20223001.png)
![image](assets/Screenshot%202022-06-08%20223228.png)

## 文件目录

### 文件控制块

![image](assets/Screenshot%202022-06-08%20232016.png)

+ 搜索:当用户要使用一个文件时,系统要根据文件名搜索目录,找到该文件对应的目录项
+ 创建文件:创建一个新文件时,需要在其所属的目录中增加一个目录项
+ 删除文件:当删除一个文件时,需要在目录中删除相应的目录项
+ 显示目录:用户可请求显示目录的内容,如显示该目录中的所有文件及相应属性
+ 修改目录:某些文件属性保存在目录中,因此这些属性变化时需要修改相应的目录项(如,文件重命名)

### 单级目录结构

![image](assets/Screenshot%202022-06-09%20195153.png)

### 两级目录结构

![image](assets/Screenshot%202022-06-09%20202824.png)

### 多级目录结构(树形目录结构)

![image](assets/Screenshot%202022-06-09%20205311.png)
![image](assets/Screenshot%202022-06-09%20205645.png)
![image](assets/Screenshot%202022-06-09%20205826.png)

### 无环图目录结构

![image](assets/Screenshot%202022-06-09%20210156.png)
可以用不同的文件名指向同一个文件,甚至可以指向同一个目录(共享同一目录下的所有内容).  
需要为每个共享结点设置一个共享计数器,用于记录此时有多少个地方在共享该结点.用户提出删除结点的请求时,只是删除该用户的FCB,并使共享计数器减1,并不会直接删除共享结点.  
只有共享计数器减为0时,才删除结点.  
注意:共享文件不同于复制文件.在共享文件中,由于各用户指向的是同一个文件,因此只要其中一个用户修改了文件数据,那么所有用户都可以看到文件数据的变化.

### 索引结点(FCB的改进)

![image](assets/Screenshot%202022-06-09%20211314.png)
当找到文件名对应的目录项时,才需要将索引结点调入内存,索引结点中记录了文件的各种信息,包括文件在外存中的存放位置,根据"存放位置"即可找到文件.  
存放在外存中的索引结点称为"磁盘索引结点",当索引结点放入内存后称为"内存索引结点".  
相比之下内存索引结点中需要增加一些信息,比如:文件是否被修改,此时有几个进程正在访问该文件等.

### 小结

![](assets/Screenshot%202022-06-09%20215159.png)

## 文件的物理结构
### 连续分配
![](assets/Screenshot%202022-06-11%20203432.png)
读取某个磁盘块时,需要移动磁头.访问的两个磁盘块相隔越远,移动磁头所需时间就越长.  
结论:连续分配的文件在顺序读/写时速度最快,但是不方便文件的拓展,会产生磁盘碎片,存储空间利用率低
### 链接分配
链接分配采取离散分配的方式,可以为文件分配离散的磁盘块.分为隐式链接和显式链接两种
+ 隐式链接
![](assets/Screenshot%202022-06-11%20214732.png)
除文件的最后一个盘块之外,每个盘块中都存有指向下一盘块的指针.文件目录包括文件第一块的指针和最后一块的指针.  
优点:很方便文件拓展,不会有碎片问题,外存利用率高.  
缺点:只支持顺序访问,不支持随机访问,查找效率低,指向下一个盘块的指针也需要耗费少量的存储空间.
+ 显式链接
![](assets/Screenshot%202022-06-11%20225446.png)
![](assets/Screenshot%202022-06-11%20233633.png)
优点:很方便文件拓展,不会有碎片问题,外存利用率应由,并且支持随机访问.相比于隐式链接来说,地址转换时不需要访问磁盘,因此文件的访问效率更高.  
缺点:文件分配表需要占用一定的存储空间

### 索引分配
索引分配允许文件离散地分配在各个磁盘块中,系统会为每个文件建立一张索引表,索引表中记录了文件的各个逻辑块对应的物理块(索引表的功能类似于内存管理中的页表--建立逻辑页面到物理页之间的映射关系).索引表存放的磁盘块称为索引块.文件数据存放的磁盘块称为数据块.
![](assets/Screenshot%202022-06-12%20133223.png)
+ 链接方案:如果索引表太大,一个索引块装不下,那么可以将多个索引块链接起来存放
![](assets/Screenshot%202022-06-12%20162821.png)
+ 多层索引:建立多层索引(原理类似于多级页表).使第一层索引块指向第二层的索引块.还可根据文件大小的要求再建立第三层,第四层索引块.
![](assets/Screenshot%202022-06-12%20210107.png)
+ 混合索引:多种索引分配方式的结合.例如,一个文件的顶级索引表中,即包含直接地址索引(直接指向数据块),又包含一级间接索引(指向单层索引表),还包含两级间接索引(指向两层索引表).
![](assets/Screenshot%202022-06-12%20211210.png)

### 索引分配(总结)
![](assets/Screenshot%202022-06-12%20211557.png)

### 小结
![](assets/Screenshot%202022-06-12%20211805.png)

## 文件存储空间管理
### 存储空间的划分与初始化
![](assets/Screenshot%202022-06-13%20193955.png)
### 空闲表法
![](assets/Screenshot%202022-06-13%20195108.png)
### 空闲链表法
![](assets/Screenshot%202022-06-13%20195436.png)
![](assets/Screenshot%202022-06-13%20195710.png)
![](assets/Screenshot%202022-06-13%20200303.png)

### 位示图法
![](assets/Screenshot%202022-06-13%20205550.png)
+ 如何分配:若文件需要K个块
  1. 顺序扫描位示图,找到K个相邻或不相邻的"0"
  2. 根据字号,位号算出对应的盘块号,将相应盘块分配给文件
  3. 将相应位设置为"1"
+ 如果回收
  1. 根据回收的盘块号计算出对应的字号,位号
  2. 将相应二进制位设为"0"

### 成组链接法
空闲表法,空闲链表法不适用于大型文件系统,因为空闲表或空闲链表可能过大.UNIX系统中采用了成组链接法对磁盘空闲块进行管理  
文件卷的目录区中专门用一个磁盘块作为"超级块",当系统启动时需要将超级块读入内存.并且要保证内存与外存中的"超级块"数据一致
![](assets/Screenshot%202022-06-13%20211115.png)
![](assets/Screenshot%202022-06-13%20211602.png)
+ 如何分配
  + 需要1个空闲块
    1. 检查第一个分组的块数是否足够.1 < 100,因此是足够的.
    2. 分配第一个分组中的1个空闲块,并修改相应数据
  + 需要100个空闲块
    1. 检查第一个分组的场数是否足够. 100 = 100 ,是足够的
    2. 分配第一个分组中的100个空闲块.但是由于300号块内存放了再下一组的信息,因此300号块的数据需要复制到超级块中

### 小结
![](assets/Screenshot%202022-06-13%20223105.png)

## 文件的基本操作
### 创建文件
![](assets/Screenshot%202022-06-19%20184636.png)
### 删除文件
![](assets/Screenshot%202022-06-21%20193515.png)
### 打开文件
![](assets/Screenshot%202022-06-21%20193830.png)
![](assets/Screenshot%202022-06-21%20195145.png)
### 关闭文件
![](assets/Screenshot%202022-06-21%20195706.png)
### 读文件
![](assets/Screenshot%202022-06-21%20201307.png)
### 写文件
![](assets/Screenshot%202022-06-21%20201959.png)

### 小结
![](assets/Screenshot%202022-06-22%20201449.png)

## 文件共享
### 基于索引结点的共享方式(硬链接)
知识回顾:索引结点,是一种文件目录瘦身策略.由于检索文件时只需要用到文件名,因此可以将除了文件名之外的其他信息放到索引结点中.这样目录项就只需要包含文件名,索引结点指针.
![](assets/Screenshot%202022-06-30%20064757.png)
索引结点中设置一个链接计数变量count,用于表示链接到本索引结点上的用户目录项数.  
若count=2,说明此时有两个用户目录项链接到该索引结点上,或者说是有两个用户在共享此文件.  
若某个用户决定"删除"该文件,则只是要把用户目录中与该文件对应的目录项删除,且索引结点的count值减1..  
若count>0,说明还有别的用户要使用该文件,暂时不能把文件数据删除,否则会导致指针悬空.  
当count=0时系统负责删除文件.

### 基于符号链的共享方式(软链接)
![](assets/Screenshot%202022-06-30%20065849.png)
当User3访问"ccc"时,操作系统判断文件"ccc"属于Link类型文件,于是会根据其中记录的路径层层查找目录,最终找到User1的目录表中的"aaa"表项,于是就找到了文件1的索引结点.

### 小结
![](assets/Screenshot%202022-06-30%20070424.png)
速度比硬链接慢

## 文件保护
### 口令保护
为文件设置一个"口令"(如:abc123456),用户请求访问该文件时必须提供"口令".  
口令一般存放在文件对应的FCB或索引结点中.用户访问文件前需要先输入"口令",操作系统会将用户提供的口令与FCB中存储的口令进行对比,如果正确,则允许该用户访问文件.
+ 优点:保存口令的空间开销不多,验证口令的时间开销也很小.
+ 缺点:正确的"口令"存放在系统内部,不够安全.

### 加密保护
使用某个"密码"对文件进行加密,在访问文件时需要提供正确的"密码"才能对文件进行正确的解密
![](assets/Screenshot%202022-07-02%20102448.png)
+ 优点:保密性强,不需要在系统中存储"密码"
+ 缺点:编码/译码,或者说加密/解密要花费一定时间
### 访问控制
在每个文件的FCB(或索引结点)中增加一个访问控制列表(Access-Control List,ACL),该表中记录了各个用户可以对该文件执行哪些操作
![](assets/Screenshot%202022-07-02%20115911.png)
![](assets/Screenshot%202022-07-02%20121202.png)
### 小结
![](assets/Screenshot%202022-07-02%20122357.png)

## 文件系统的层次结构
![](assets/Screenshot%202022-07-02%20182703.png)
### 用户接口
文件系统需要向上层的用户提供一些简单易用的功能接口.这层就是用于处理用户发出的系统调用请求(Read,Write,Open,Close等系统调用)
### 文件目录系统
用户是通过文件路径来访问文件的,因此这一层需要根据用户给出的文件路径找到相应的FCB或索引结点.所有和目录,目录项相关的管理工作都在本层完成,如:管理活跃的文件目录表,管理打开文件表等.
### 存取控制模块
为了保证文件数据的安全,还需要验证用户是否有访问权限.这一层主要完成了文件保护相关功能
### 逻辑文件系统与文件信息缓冲区
用户指明想要访问文件记录号,这一层需要将记录号转换为对应的逻辑地址
### 物理文件系统
这一层需要把上一层提供的文件逻辑地址转换为实际的物理地址
### 辅助分配模块
负责文件存储空间的管理,即负责分配和回收存储空间
### 设备管理模块
直接与硬件交互,负责和硬件直接相关的一些管理工作.如:分配设备,分配设备缓冲区,磁盘调度,启动设备,释放设备等

## 磁盘的结构
### 磁盘,磁道,扇区
+ 磁盘:表面由一些磁性物质组成,可以用这些磁性物质来记录二进制数据
+ 磁道:磁盘的盘面被划分成一个个的圈
+ 扇区:一个磁道又被划分成一个个扇区,每个扇区就是一个"磁盘块".各个扇区存放的数据量相同(如1KB),因为最内侧磁道上的扇区面积最小,所以数据密度最大

### 如何在磁盘中读/写数据
需要把"磁头"移动到想要读/写的扇区所在的磁道.  
磁盘会转起来,让目标扇区从碰头下面划过,才能完成对扇区的读/写操作.

### 盘面,柱面,磁盘的物理地址
![](assets/Screenshot%202022-07-04%20213008.png)
### 小结
![](assets/Screenshot%202022-07-04%20213507.png)

## 磁盘调度算法
### 一次磁盘读/写操作需要的时间
![](assets/Screenshot%202022-07-05%20085047.jpg)
### 先来先服务算法(FCFS)
![](assets/Screenshot%202022-07-05%20085921.png)
### 最短寻找时间优先(SSTF)
![](assets/Screenshot%202022-07-05%20090540.jpg)
### 扫描算法(SCAN)
![](assets/Screenshot%202022-07-05%20091301.jpg)
### LOOK调度算法
![](assets/Screenshot%202022-07-05%20091651.jpg)
### 循环扫描算法(C-SCAN)
![](assets/Screenshot%202022-07-05%20092114.jpg)
### C-LOOK调度算法
![](assets/Screenshot%202022-07-05%20092405.jpg)
### 小结
![](assets/Screenshot%202022-07-05%20092654.jpg)

## 减少磁盘延迟时间的方法
![](assets/Screenshot%202022-07-06%20130709.jpg)
### 减少延迟时间的方法:交替编号
![](assets/Screenshot%202022-07-06%20131120.jpg)
### 磁盘地址结构的设计
![](assets/Screenshot%202022-07-06%20131510.jpg)
![](assets/Screenshot%202022-07-06%20131740.jpg)
所以,如果采用(柱面号,盘面号,扇区号)的地址结构可以在读取地址连续的磁盘块时,减少磁头移动消耗的时间.
### 减少延迟时间的方法:错位命名
![](assets/Screenshot%202022-07-06%20132337.jpg)
![](assets/Screenshot%202022-07-06%20132603.jpg)
### 小结
![](assets/Screenshot%202022-07-06%20132725.jpg)

## 磁盘的管理
### 磁盘初始化
![](assets/Screenshot%202022-07-07%20131458.jpg)
### 引导块
![](assets/Screenshot%202022-07-07%20132034.jpg)
### 坏块的管理
![](assets/Screenshot%202022-07-07%20132842.jpg)
### 小结
![](assets/Screenshot%202022-07-07%20133246.jpg)

## I/O设备的概念和分类
I/O设备就是可以将数据输入到计算机,或者可以接收计算机输出数据的外部设备,属于计算机中的硬件部件.  
UNIX系统将外部设备抽象为一种特殊的文件,用户可以使用与文件操作相同的方式对外部设备进行操作.
### 小结
![](assets/Screenshot%202022-07-09%20102039.png)

## I/O控制器
CPU无法直接控制I/O设备的机械部件,因此I/O设备还要有一个电子部件作为CPU和I/O设备机械部件之间的"中介",用于实现CPU对设备的控制.  
这个电子部件就是I/O控制器,又称设备控制器.CPU可控制I/O控制器,又由I/O控制器来控制设备的机械部件.
![](assets/Screenshot%202022-07-09%20105912.png)
### I/O控制器的组成
![](assets/Screenshot%202022-07-09%20111644.png)
1. 一个I/O控制器可能会对应多个设备;
2. 数据寄存器,控制寄存器,状态寄存器可能有多个(如:每个控制/状态寄存器对应一个具体的设备),且这些寄存器都要有相应的地址,才能方便CPU操作.有的计算机会让这些寄存器占用内存地址的一部分,称为内存映像I/O;另一些计算机则采用I/O专用地址,即寄存器独立编址.
### 内存映像I/O vs. 寄存器独立编址
![](assets/Screenshot%202022-07-09%20154107.png)
### 小结
![](assets/Screenshot%202022-07-09%20154249.png)

## I/O控制方式
### 程序直接控制方式
Key word : 轮询
1.完成一次读/写操作的流程(以读操作为例)
![](assets/Screenshot%202022-07-10%20092616.png)
![](assets/Screenshot%202022-07-10%20093946.png)

### 中断驱动方式
![](assets/Screenshot%202022-07-10%20100248.png)
![](assets/Screenshot%202022-07-10%20101533.png)

### DMA方式
与"中断驱动方式"相比,DMA方式(Direct Memory Access, 直接存储器存取.主要用于块设备的I/O控制)有这样几个改进:
1. 数据的传送单位是"块",不再是一个字,一个字的传送.
2. 数据的流向是从设备直接放入内存,或者从内存直接到设备,不再需要CPU作为"快递小哥".
3. 仅在传送一个或多个数据块的开始和结束时,才需要CPU干预.

![](assets/Screenshot%202022-07-10%20121240.png)
![](assets/Screenshot%202022-07-10%20131942.png)
![](assets/Screenshot%202022-07-10%20134431.png)

### 通道控制方式
![](assets/Screenshot%202022-07-10%20193954.png)
![](assets/Screenshot%202022-07-10%20193153.png)
### 小结
![](assets/Screenshot%202022-07-10%20194348.png)

## I/O软件层次结构
![](assets/Screenshot%202022-07-11%20202243.png)
### 用户层软件
![](assets/Screenshot%202022-07-11%20204434.png)
### 设备独立性软件
又称设备无关性软件.与设备的硬件特性无关的功能几乎都在这一层实现.
1. 向上层提供统一的调用接口(如read/write系统调用)
2. 设备的保护,原理类似与文件保护.设备被看做是一种特殊的文件,不同用户对各个文件的访问权限是不一样的,同理,对设备的访问权限也不一样.
3. 差错处理,设备独立性软件需要对一些设备的错误进行处理
4. 设备的分配与回收
5. 数据缓冲区的管理,可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异
6. 建立逻辑设备名到物理设备名的映射关系;根据设备类型选择调用相应的驱动程序
    ![](assets/Screenshot%202022-07-11%20205827.png)
    ![](assets/Screenshot%202022-07-11%20210140.png)
    ![](assets/Screenshot%202022-07-11%20210203.png)

### 设备驱动程序
主要负责对硬件设备的具体控制,将上层发出的一系列命令(如read/write)转化成特定设备"能听得懂"的一系列操作.包括设置设备寄存器;检查设备状态等;  
不同的I/O设备有不同的硬件特性,具体细节只有设备的厂家才知道.因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序.  
驱动程序一般会以一个独立进程的方式存在.

### 中断处理程序
当I/O任务完成时,I/O控制器会发送一个中断信号,系统会根据中断信号类型找到相应的中断处理程序并执行.中断处理程序的处理流程如下:
![](assets/Screenshot%202022-07-11%20211957.png)

## I/O核心子系统
### I/O调度
与文件读写的算法算不多
### 设备保护
文件保护啦 

## 假脱机技术
又称"SPOOLing技术"是用软件的方式模拟脱机技术.
![](assets/Screenshot%202022-07-12%20090518.jpg)
### 小结
![](assets/Screenshot%202022-07-12%20091306.jpg)

## 设备的分配与回收
### 设备的固有属性
+ 独占设备:一个时段只能分配给一个进程(如打印机)
+ 共享设备:可同时分配给多个进程使用(如磁盘),各进程往往是宏观上同时共享使用设备,而微观上交替使用
+ 虚拟设备:采用SPOOLing技术将独占设备改造成虚拟的共享设备,可同时分配给多个进程使用(如采用SPOOLing技术实现的共享打印机)
### 设备分配算法
+ 先来先服务
+ 优先级高者优先
+ 短任务优先
+ ...

### 设备分配中的安全性
![](assets/Screenshot%202022-07-12%20131857.jpg)

### 静态分配和动态分配
+ 静态分配: 进程运行前为其分配全部所需资源,运行结束后归还资源.破坏了"请求和保持"条件,不会发生死锁
+ 动态分配:进行运行过程中动态申请设备资源

### 设备分配管理中的数据结构
![](assets/Screenshot%202022-07-12%20132432.jpg)
设备控制表(DCT):系统为每个设备配置一张DCT,用于记录设备情况
![](assets/Screenshot%202022-07-12%20202738.png)
控制器控制表(COCT):每个设备控制器都会对应一张COCT.操作系统根据COCT的信息对控制器进行操作和管理.
![](assets/Screenshot%202022-07-13%20084509.jpg)
通道控制表(CHCT):每个通道都会对应一第CHCT.操作系统根据CHCT的信息对通道进行操作和管理
![](assets/Screenshot%202022-07-13%20084749.jpg)
系统设备表(SDT):记录了系统中全部设备的情况,每个设备对应一个表目
![](assets/Screenshot%202022-07-13%20084952.jpg)
### 设备分配的步骤
1. 根据进程请求的物理设备名查找SDT(注:物理设备名是进程请求分配设备时提供的参数)
2. 根据SDT找到DCT,若设备忙碌则将进程PCB挂到设备等待队列中,不忙碌则将设备分配给进程
3. 根据DCT找到COCT,若控制器忙碌则将进程PCB挂到控制器等待队列中,不忙碌则将控制器分配给进程
4. 根据COCT找到CHCT,若通道忙碌则将进行PCB挂到通道等待队列中,不忙碌则将通道分配给进行.

注:只有设备,控制器,通道三者都分配成功时,这次设备分配才算成功,之后便可启动I/O设备进行数据传送.

缺点:
1. 用户编程时必须使用"物理设备名",底层细节对用户不透明,不方便编程
2. 若换了一个物理设备,则程序无法运行
3. 若进程请求的物理设备正在忙碌,则即使系统中还有同类型的设备,进程也必须阻塞等待

改进方法:建立逻辑设备名与物理设备名的映射机制,用户编程时只需提供逻辑设备名

### 设备分配步骤的改进
![](assets/Screenshot%202022-07-13%20090709.jpg)
![](assets/Screenshot%202022-07-13%20090938.jpg)
### 小结
![](assets/Screenshot%202022-07-13%20091535.jpg)

## 缓冲区管理
缓冲区是一个存储区域,可以由专门的硬件寄存器组成,也可利用内存作为缓冲区.  
使用硬件作为缓冲区的成本较高,容量也较小,一般仅用在对速度要求非常高的场合(如存储器管理中所用的联想寄存器,由于对页表的访问频率极高,因此使用速度很快的联想寄存器来存放页表的副本)  
一般情况下,更多的是利用内存作为缓冲区,"设备独立性软件"的缓冲区管理就是要组织管理好这些缓冲区.

### 缓冲区的作用
1. 缓和CPU与I/O设备之间速度不匹配的矛盾
2. 减少对CPU的中断频率,放宽对CPU中断相应时间的限制
3. 解决数据粒度不匹配的问题(如:输出进程每次可以生成一块数据,但I/O设备每次只能输出一个字符)
4. 提高CPU与I/O设备之间的并行性

### 单缓冲
假设某用户进程请求某种块设备读入若干块的数据.若采用单缓冲的策略,操作系统会在主存中为其分配一个缓冲区(若题目中没有特别说明,一个缓冲区的大小就是一个块).  
注意:当缓冲区数据非空时,不能往缓冲区冲入数据,只能从缓冲区把数据传出;当缓冲区为空时,可以往缓冲区冲入数据,但必须把缓冲区充满以后,才能从缓冲区把数据传出.
### 双缓冲
操作系统会在主存中为其分配两个缓冲区(若题目中没有特别说明,一个缓冲区的大小就是一个块)
### 使用单/双缓冲在通信时的区别
两台机器之间通信时,可以配置缓冲区用于数据的发送和接受
![](assets/Screenshot%202022-07-13%20135101.jpg)
![](assets/Screenshot%202022-07-13%20135329.jpg)


