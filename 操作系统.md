## 操作系统的定义
> 操作系统(Operating System,OS)是指控制和管理整个计算机系统的硬件和软件资源,并合理地组织高度计算机的工作和资源的分配,以提供给用户和其他软件方便的接口和环境,它是计算机系统中最基本的系统软件.
> ![](assets/Screenshot%202022-02-05%20233650.png)

## 特征
### 并发
> 指两个或多个事件在同一时间间隔内发生.这些事件宏观上是同时发生的,但微观上是交替发生的.与**并行**不同,**并行**指两个或多个事件在同一时刻同时发生.  
> 操作系统的并发性指计算机系统中同时存在着多个运行着的程序.  
> 一个单核处理机(CPU)同一时刻只能执行一个程序,因此操作系统会负责协调多个程序交替执行(这此程序微观上是交替执行的,但宏观上看起来就像在同时执行)  
> 事实上,操作系统就是伴随着"多道程序技术"而出现的.因此,操作系统和程序并发是一起诞生的.  
> 当今的计算机,一般都是多核CPU,比如Intel的第八代i3处理器就是4核CPU,这意味着同一时刻可以有4个程序**并行**执行,但是操作系统的并发性依然必不可少,当代人使用计算机绝对有4个以上的程序需要同时工作.
### 共享
> 即资源共享,是指系统中的资源可供内存中多个并发执行的进程共同使用.
> + 互斥共享方式
>   > 系统中的某些资源,虽然可以提供给多个进程使用,但一个时间段内只允许一个进程访问资源.
> + 同时共享方式
>   > 系统中的某些资源,允许一个时间段内由多个进程"同时"对它们进行访问.所谓的"同时"往往是宏观上的,而在微观上,这此进程可能是交替地对该资源进行访问的(即分时共享),当然出可能出现微观上同时的情况,比如用扬声器同时放两首歌(但是我觉得只是两个进程了同一个内存区域了)

### 并发和共享的关系
![](assets/Screenshot%202022-02-06%20164836.png)

### 虚拟
> 虚拟是指把一个物理上的实体变为若干个逻辑上的对应物.物理实体(前者)是实现存在的,而逻辑上对应物(后者)是用户感觉到的.
> ![](assets/Screenshot%202022-02-06%20170037.png)


### 异步
> 在多道程序环境下,允许多个程序并发执行,但由于资源有限,进程的执行不是一贯到底的,而是走走停停,以不可预知的速度向前推进,这就是进程的异步性.

![](assets/Screenshot%202022-02-06%20171352.png)

## OS的发展阶段
![](assets/Screenshot%202022-02-07%20200105.png)
+ 手工操作阶段
  ![](assets/Screenshot%202022-02-07%20185140.png)
+ 单道批处理系统
  ![](assets/Screenshot%202022-02-07%20192252.png)
+ 多道批处理系统
  > 主要优点:多道程序并发执行,共享计算机资源.资源利用率大幅提升,CPU和其他资源保持"忙碌"状态,系统吞吐量增大.  
  > 主要缺点:用户响应时间长,没有人机交互功能(用户提交自己的作业之后就只能等待计算机处理完成,中间不能控制自己的作业执行)
  > ![](assets/Screenshot%202022-02-07%20192919.png)
+ 分时操作系统
  > 计算机以时间片为单位轮流为各个用户/作业服务,各个用户可通过终端与计算机进行交互.  
  > 主要优点:用户请求可以被即时响应,解决了人机交互问题.允许多个用户同时使用一个计算机,并且用户对计算机的操作相互独立,感受不到别人的存在.  
  > 主要缺点:不能优先处理一些紧急任务.操作系统对各个用户/作业都是完全公平的,循环地为每个用户/作业服务一个时间片,不区分任务的紧急性.  
  > ![](assets/Screenshot%202022-02-07%20194603.png)

+ 时间操作系统
  > 主要优点:能够优先响应一些紧急任务,某些紧急任务不需时间片排队.  
  > 在实时操作系统的控制下,计算机系统接收到外部信号后及时进行处理,并且要在严格的时限内处理完事件.实时操作系统的主要特点是及时性和可靠性.  
  > ![](assets/Screenshot%202022-02-07%20195504.png)

+ 其他
  1. 网络操作系统:是伴随着计算机网络的发展而诞生的,能把网络中各个计算机有机地结合起来,实现数据传送等功能,实现网络中各种资源的共享(如文件共享)和各台计算机之间的通信.(如:Windows NT 就是一种典型的网络操作系统,网站服务器就可以使用)
  2. 分布式操作系统:主要特点是分布性和并行性.系统中的各台计算机地位相同,任何工作都可以分布在这些计算机上,由它们并行,协同完成这个任务.
  3. 个人计算机操作系统:如Windows XP,MacOS,方便个人使用.

## 两种指令
> 处理器(CPU)能识别,执行的最基本命令,比如,加法指令就是让CPU进行加法运算.
+ 特权指令:不允许用户程序使用,如"内存清零指令"
+ 非特权指令:如普通的运算指令

## 两种处理器状态
> 用程序状态字寄存器(PSW)中的某标志位来标识当前处理器处于什么状态.如0为用户态,1为核心态
+ 用户态(目态):此时CPU只能执行非特权指令
+ 核心态(管态):特权指令,非特权指令都可执行

## 两种程序
+ 内核程度:操作系统的内核程序是系统的管理者,既可以执行特权指令,也可以执行非特权指令,运行在核心态.
+ 应用程序:为了保证系统能安全运行,普通应用程序只能执行非特权指令,运行在用户态.

## 操作系统的内核
> 内核是计算机上配置的底层软件,是操作系统最基本,最核心的部分.  
> 实现操作系统内核功能的那些程序就是内核程序
> ![](assets/Screenshot%202022-02-08%20192945.png)
> ![](assets/Screenshot%202022-02-08%20193254.png)

## 操作系统的体系结构D
+ 大内核
  > 将操作系统的主要功能模块都作为系统内核,运行在核心态
  + 优点:高性能
  + 缺点:内核代码庞大,结构混乱,难以维护
+ 微内核
  > 只把基本的功能保留在内核
  + 优点:内核功能少,结构清晰,方便维护
  + 缺点:需要频繁地在核心态和用户态之间切换,性能低

## 小结
![](assets/Screenshot%202022-02-08%20194513.png)

## 中断机制的诞生
> 早期的计算机,各程序只能串行执行,系统资源利用率低.  
> 为了解决这个问题,人们发明了操作系统(作为计算机制管理者),引入中断机制,实现了多道程序并发执行.  
> 本质:发生中断就意味着需要操作系统介入,开展管理工作  
> 大概流程:在用户态下,CPU收到计时部件发出的中断信号,切换为核心态对中断进行处理.操作系统内核负责对中断信号进行处理,如,进程1的时间片已用完,换进程2运行,进程2运行一段时间之后,发出系统调用(内中断信号),请求输出.CPU切换为核心态,对中断进行处理.之后,操作系统接管完成输出.

## 中断的概念和作用
1. 当中断发生时,CPU立即进入核心态
2. 当中断发生后,当前运行的进程暂停运行,并由操作系统内核对中断进行处理
3. 对于不同的中断信号,会进行不同的处理
> 发生了中断,就意味着需要操作系统介入,开展管理工作.由于操作系统的管理工作(比如进程切换,分配I/O设备等)需要使用特权指令,因此CPU要从用户态转为核心态.中断可以使CPU从用户态切换为核心态,使操作系统获得计算机的控制权.有了中断,才能实现多道程序并发执行.  
> "用户态->核心态"是通过中断实现的.并且中断是唯一途径.  
> "核心态->用户态"的切换是通过执行一个特权指令,将程序状态字(PSW)的标志位设置为"用户态"

## 中断的分类
+ 第一种分类
  ![](assets/Screenshot%202022-02-08%20211706.png)
+ 第二种分类
  ![](assets/Screenshot%202022-02-08%20211957.png)

## 外中断的处理过程
![](assets/Screenshot%202022-02-08%20212415.png)

## 小结
![](assets/Screenshot%202022-02-08%20212646.png)

## 系统调用
> 应用程序通过系统调用请求操作系统的服务.系统中的各种共享资源都由操作系统统一掌管,因此在用户程序中,凡是与资源有关的操作(如存储分配,I/O操作,文件管理等),都必须通过系统调用的方式向操作系统提出服务请求,由操作系统代为完成.这样可以保证系统的稳定性和安全性,防止用户进行非法操作.
> ![](assets/Screenshot%202022-02-09%20191226.png)

## 系统调用与库函数的区别
![](assets/Screenshot%202022-02-09%20191856.png)

## 系统调用的过程
![](assets/Screenshot%202022-02-09%20192904.png)

## 小结
![](assets/Screenshot%202022-02-09%20193206.png)

## 程序
> 就是一个指令序列,早期的计算机,只支持单道程序.  
> ps: 内存中,程序的代码放在程序段内,程序运行过程处理的数据放在数据段内(如变量).  
> ![](assets/Screenshot%202022-02-10%20190535.png)
> 程序段,数据段,PCB三部分组成了进程实体(进程映像).一般情况下,我们把进程实体就简称为进程,例如,所谓创建进程,实质上是创建进程实体中的PCB;而撤销进程,实质上是撤销进程实体中的PCB.  
> 注意:PCB是进程存在的唯一标志!  
> 从不同的角度,进程可以有不同的定义,比较传统典型的定义(强调"动态性")有:
> 1. 进程是程序的一次执行过程.
> 2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动.
> 3. 进程是具有独立功能的程序在数据集合上运行的过程,它是系统进行资源分配和调试的一个独立单位.
> 
> 引入进程实体的概念后,可把进程定义为:
> + 进程是进程实体的运行过程,是系统进行资源分配和高度的一个独立单位.
> 
> **注**: 严格来说,进程实体和进程并不一样,进程实体是静态的,进程则是动态的.不过,除非题目专门考察二者区别,否则可以认为进程实体就是进程.因此我们也可以说"进程由程序段,数据段,PCB三部分组成".

## 进程的组成
> 进程(进程实体)由程序段,数据段,PCB三部分组成
> ![](assets/Screenshot%202022-02-10%20191732.png)
> ![](assets/Screenshot%202022-02-10%20192016.png)

## 进程的组织
> 在一个系统中,通常有数十,数百乃至数千个PCB.为了能对他们加以有效的管理,应该用适当的方式把这些PCB组织起来.
> ![](assets/Screenshot%202022-02-10%20192445.png)
> + 链接方式
>   ![](assets/Screenshot%202022-02-10%20192829.png)
> + 索引方式
>   ![](assets/Screenshot%202022-02-10%20192936.png)

## 进程的特征
> 进程和程序是两个截然不同的概念,相比于程序,进程拥有以下特征:
> ![](assets/Screenshot%202022-02-10%20193327.png)

## 小结
![](assets/Screenshot%202022-02-10%20193719.png)

## 进程的状态
> 进程是程序的一次执行.在这个执行过程中,有时进程正在被CPU处理,有时又需要等待CPU服务,可见,进程的状态是会有各种变化.为了方便对各个进程的管理,操作系统需要将进程合理地划分为几种状态.
+ 运行态(Running)
  > 占有CPU,并在CPU上运行.  
  > 单核处理机环境下,每一时刻最多只有一个进程处于运行态.  
  > 双核环境下可以同时有两个进程处于运行态.
+ 就绪态(Ready)
  > 已经具备运行条件,但由于没有空闲CPU,而暂时不能运行.  
  > 进程已经拥有了除处理机之外所有需要的资源,一旦获得处理机,即可立即进入运行态开始运行.  
  > 即:万事俱备,只欠CPU.
+ 阻塞态(Waiting/Blocked,又称:等待态)
  > 因等待某一事件而暂时不能运行  
  > 如:等待操作系统分配打印机,等待读磁盘操作的结果.  
  > CPU是计算机中最昂贵的部件,为了提高CPU的利用率,需要先将其他进程需要的资源分配到位,才能得到CPU的服务.
+ 创建态(New,又称:新建态)
  > 操作系统需要完成创建进程.操作系统为该进程分配所需的内存空间等系统资源,并为其创建和初始化PCB(如:为进程分配PID)
+ 终止态(Terminated,又称:结束态)
  > 进程运行结束(或者由于bug导致进程无法继续执行下去,比如数组越界错误),需要撤销进程.  
  > 操作系统需要完成撤销进程相关的工作.完成将分配给进程的资源回收,撤销进程PCB等工作.

## 进程状态的转换
![](assets/Screenshot%202022-02-12%20195707.png)

## 小结
![](assets/Screenshot%202022-02-12%20195915.png)

## 进程控制
> 对系统中的所有进程实施有效的管理,它具有创建新进程,撤销已有进程,实现进程状态转换等功能.  
> 反正进程控制就是要实现进程状态转换.

## 进程控制流程
![](assets/Screenshot%202022-02-12%20212103.png)
![](assets/Screenshot%202022-02-12%20212350.png)

## 进程控制相关的原语
> 由于进程控制会导致进程状态的转换,所以进程控制相关的原语无非要做三类事情:
1. 更新PCB中的信息(如修改进程状态标志,将运行环境保存到PCB,从PCB恢复运行环境)
   + 所有的进程控制原语一定都会修改进程状态标志
   + 剥夺当前运行进程的CPU使用权必然需要保存其运行环境
   + 某进程开始运行前必然要恢复其运行环境
2. 将PCB插入合适的队列
3. 分配/回收资源

![](assets/Screenshot%202022-02-12%20213327.png)
![](assets/Screenshot%202022-02-12%20213556.png)
![](assets/Screenshot%202022-02-12%20214700.png)
![](assets/Screenshot%202022-02-12%20214936.png)

## 小结
![](assets/Screenshot%202022-02-12%20215054.png)

## 进程通信
> 进程之间的信息交换.  
> 进程是分配系统资源的单位(包括内存地址空间),因此各进程拥有的内存地址空间相互独立.  
> 为了保证安全,一个进程不能直接访问另一个进程的地址空间.  
> 但是进程之间的信息交换又是必须实现的.为了保证进程间的安全通信,操作系统提供了一些方法.

### 共享存储
> 两个进程对共享空间的访问必须是互斥的(互斥访问通过操作系统提供的工具实现).  
> 操作系统只负责提供共享空间和同步互斥工具(如P,V操作).
+ 基于数据结构的共享
  > 比如共享空间里只能放一个长度为10的数组.这种共享方式速度慢,限制多,是一种低级通信方式.
+ 基于存储区的共享
  > 在内存中画出一块共享存储区,数据的形式,存放位置都由进程控制,而不是操作系统.相比之下,这种共享方式速度更快,是一种高级通信方式.

### 管道通信
> "管道"是指用于连接读写进程的一个共享文件,又名pipe文件.其实就是在内存中开辟一个大小固定的缓冲区.
1. 管道只能采用半双工通信,某一时间段内只能实现单向的传输.如果要实现双向同时通信,则需要设置两个管理.
2. 各进程要互斥地访问管道.
3. 数据以字符流的形式写入管道,当管道写满时,写进程的write()系统调用将被阻塞,等待读进程将数据取走.当读进程将数据全部取走后,管道变空,此时读进程的read()系统调用将被阻塞.
4. 如果没写满,就不允许读.如果没读空,就不允许写.
5. 数据一旦被读出,就从管道中被抛弃,这就意味着读进程最多只能有一个,否则可能会有读错数据的情况.

### 消息传递
![](assets/Screenshot%202022-02-13%20195839.png)

### 小结
![](assets/Screenshot%202022-02-13%20200505.png)

## 线程
![](assets/Screenshot%202022-02-13%20201945.png)
![](assets/Screenshot%202022-02-13%20202031.png)
![](assets/Screenshot%202022-02-13%20202656.png)

### 线程的属性
![](assets/Screenshot%202022-02-13%20203112.png)

### 线程的实现方式
+ 用户级线程(User-Level Thread,ULT)
  ![](assets/Screenshot%202022-02-13%20203548.png)
+ 内核级线程(Kernel-Level Thread,KLT,又称"内核支持的线程")
  ![](assets/Screenshot%202022-02-13%20203935.png)

![](assets/Screenshot%202022-02-13%20204209.png)

### 多线程模型
1. ![](assets/Screenshot%202022-02-13%20204532.png)
2. ![](assets/Screenshot%202022-02-13%20204733.png)
3. ![](assets/Screenshot%202022-02-13%20204903.png)

### 小结
![](assets/Screenshot%202022-02-13%20205124.png)

## 调度的基本概念
> 当有一堆任务要处理,但由于资源有限,这些事情没法同时处理.这就需要确定某种规则来决定处理这些任务的顺序,这就是"调度"研究的问题.  
> 在多道程序系统中,进程的数量往往是多于处理机的个数的,这样不可能同时并行地处理各个进程.处理机调度,就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行,以实现进程的并发执行.

### 高级调度
> 由于内存空间有限,有时无法将用户提交的作业全部放入内存,因此就需要确定某种规则来决定将作业调入内存的顺序.  
> 高级调度(作业调度).按一定的原则从外存上处于后备队列的作业中挑选一个(或多个)作业,给它们分配内存等必要资源,并建立相应的进程(建立PCB),以使它(们)获得竞争处理机的权利.  
> 高级调度是辅存(外存)与内存之间的调度.每个作业只调入一次,调出一次.作业调入时建立相应的PCB,作业调出时才撤销PCB.高级调度主要是指调入的问题,因为只有调入的时机需要操作系统来确定,但调出的时机必然是作业运行结束才调出.

### 中级调度
> 引入了虚拟存储技术之后,可将暂时不能运行的进程调至外存等待.等它重新具备了运行条件且内存又稍有空间时,再重新调入内存.  
> 这么做的目的是为了提高内存利用率和系统吞吐量.  
> 暂时调到外存等待的进程状态为挂起状态.值得注意的是,PCB并不会一起调到外存,而是会常驻内存.PCB中会记录进程数据在外存中的存放位置,进程状态等信息,操作系统通过内存中的PCB来保持对各个进程的监控,管理.被挂起的进程PCB会被放到挂起队列中.  
> 中级调度(内存调度),就是要决定哪个处于挂起状态的进程重新调入内存.  
> 一个进程可能会被多次调出,调入内存,因此中级调度发生的频率要比高级调试更高.

### 七状态模型
![](assets/Screenshot%202022-02-14%20192957.png)

### 低级调度
> 低级调度(进程调试),其主要任务是按照某种方法和策略从就绪队列中选取一个进程,将处理机分配给它.  
> 进程调度是操作系统中最基本的一种调试,在一般的操作系统中都必须配置进程调度.  
> 进程调试的频率很,一般几十毫秒一次.

### 对比
|                    |                              要做什么                              |      调试发生在      | 发生频率 |         对进程状态的影响         |
| :----------------: | :----------------------------------------------------------------: | :------------------: | :------: | :------------------------------: |
| 高级调度(作业调试) | 按照某种规则,从后备队列中选择合适的作业将其调入内存,并为其创建进程 | 外在->内存(面向作业) |   最低   |        无->创建态->就绪态        |
| 中级调试(内存调度) |      按照某种规则,从扶起队列中选择合适的进程将其数据调回内存       | 外存->内存(面向进程) |   中等   | 挂起态->就绪态(阻塞挂起->阻塞态) |
| 低级调度(进程调度) |        按照某种规则,从就绪队列中选择一个进程为其分配处理机         |      内存->CPU       |   最高   |          就绪态->运行态          |

### 小结
![](assets/Screenshot%202022-02-14%20194520.png)

## 进程调度的时机
> 进程调度(低级调试),就是按照某种算法从就绪队列中选择一个进程为其分配处理机.

![](assets/Screenshot%202022-02-15%20174823.png)
![](assets/Screenshot%202022-02-15%20175331.png)
![](assets/Screenshot%202022-02-15%20175356.png)
![](assets/Screenshot%202022-02-15%20175635.png)
![](assets/Screenshot%202022-02-15%20175815.png)
![](assets/Screenshot%202022-02-15%20175913.png)

### 进程调试的方式
+ 非剥夺调度方式,又称非抢占方式
  > 只允许进程主动放弃处理机.在运行过程中即便有更紧迫的任务到达,当前进程依然会继续使用处理机,直到该进程终止或主动要求进入阻塞态.  
  > 特点是,实现简单,系统开销小但是无法及时处理紧急任务,适合于早期的批处理系统.
+ 剥夺调试方式,又称抢占方式.
  > 当一个进程正在处理机上执行时,如果有一个更重要或更紧迫的进程需要使用处理机,则立即暂停正在执行的进程,将处理机分配给更重要紧迫的那个进程.  
  > 可以优先处理更紧急的进程,也可实现让各进程按时间片轮流执行的功能(通过时钟中断).适合于分时操作系统,实时操作系统.

### 进程的切换与过程
"狭义的进程调度"与"进程切换"的区别:  
狭义的进程调试指的是从就绪队列中选中一个要运行的进程.(这个进程可以是刚刚被暂停执行的进程,也可能是另一个进程,后一种情况就需要进程切换)  
进程切换是指一个进程让出处理机,由另一个进程占用处理机的过程.  
广义的进程调试包含了选择一个进程和进程切换两个步骤.

进程切换的过程主要完成了:
1. 对原来运行进程各种数据的保存.
2. 对新的进程各种数据的恢复(如:程序计数器,程序状态字,各种数据寄存器等处理机现场信息,这些信息一般保存在进程控制块中)

注意: 进程切换是有代价的,因此如果过于频繁的进行调度,切换,必然会使整个系统的效率降低,使系统大部分时间都花在了进程切换上,而真正用于执行进程的时间减少.

### 小结
![](assets/Screenshot%202022-02-15%20182345.png)

## 调试算法的评价指标

### CPU利用率
由于早期的CPU造价极其昂贵,因此人们会希望让CPU尽可能多地工作  
CPU利用率:指CPU"忙碌"的时间占总时间的比例.

### 系统吞吐量
对于计算机来说,希望能用尽可能少的时间处理完尽可能多的作业  
系统吞吐量:单位时间内完成作业的数量


### 周转时间
![](assets/Screenshot%202022-02-16%20190731.png)
![](assets/Screenshot%202022-02-16%20191231.png)

### 等待时间
计算机的用户希望自己的作业尽可能少的等待处理机  
等待时间,指进程/作业处于等待处理机状态时间之和,等待时间越长,用户满意度越低
![](assets/Screenshot%202022-02-16%20194018.png)
对于进程来说,等待时间就是进程建立后等待被服务的时间之和,在等待I/O完成的期间其实进程也是在被服务的,所以不计入等待时间.  
对于作业来说,不仅要考虑建立进程后的等待时间,还要加上作业在外存后备队列中等待的时间.  
一个作业总共要被CPU服务多久,被I/O设备服务多久一般是确定不变的,因此调试算法其实只会影响作业/进程的等待时间.当然,与前面指标类似,也在"平均等待时间"来评价整体性能.

### 响应时间
对于计算机用户来说,会希望自己的提交的请求(比如通过键盘输入了一个调试命令)尽早地开始被系统服务,回应.  
响应时间,指从用户提交请求到首次产生响应所用的时间.

### 小结
![](assets/Screenshot%202022-02-16%20194655.png)

## FCFS,SJF,HRRN调试算法

### 先来先服务(FCFS,First Come First Serve)
![](assets/Screenshot%202022-02-17%20210626.png)

### 短作业优先(SJF,Shortest Job First)
![](assets/Screenshot%202022-02-19%20115604.png)

### 高响应比优先(HRRN,Highest Response Ratio Next)
![](assets/Screenshot%202022-02-19%20124812.png)

### 对比
|  算法   |                            可抢占                            |                        优点                         |                         缺点                         | 考虑到等待时间和运行时间 | 会导致饥饿吗 |
| :-----: | :----------------------------------------------------------: | :-------------------------------------------------: | :--------------------------------------------------: | :----------------------: | :----------: |
|  FCFS   |                           非抢占式                           |                    公平,实现简单                    |                     对短作业不利                     |      只考虑等待时间      |     不会     |
| SJF/SPF | 默认为非抢占式,也有SJF的抢占式版本最短剩余时间优先算法(SRTN) |             "最短的"平均等待和周转时间              | 对长作业不利,可能会导致饥饿.难以做到真正的短作业优先 |     只考虑了运行时间     |      会      |
|  HRRN   |                           非抢占式                           | 上述两种算法的权衡折中,综合考虑了等待时间和运行时间 |                                                      |         都考虑了         |     不会     |

注:这几种算法主要关心对用户的公平性,平均周转时间,平均等待时间等评价系统整体性能和指标,但是不关心"响应时间",也并不区分任务的紧急程度,因此对于用户来说,交互性很糟糕.因此这三种算法一般适合用于早期的批处理系统,当然,FCFS算法也常结合其他的算法使用,在现在也扮演着很重要的角色.

## 时间片轮转,优先级调试,多级反馈队列
### 时间片轮转
![](assets/Screenshot%202022-02-19%20201353.png)
![](assets/Screenshot%202022-02-19%20201438.png)

### 优先级调试算法
![](assets/Screenshot%202022-02-20%20192850.png)
![](assets/Screenshot%202022-02-20%20192726.png)

###   多级反馈队列调试算法
![](assets/Screenshot%202022-02-20%20213220.png)

### 对比
|     算法     |        可抢占         |           优点            |            缺点             | 会导致饥饿吗 |              补充              |
| :----------: | :-------------------: | :-----------------------: | :-------------------------: | :----------: | :----------------------------: |
|  时间片轮转  |        抢占式         |    公平,适用于分时系统    | 频繁切换有开销,不区分优先级 |     不会     | 时间片太小或太大会有不同的变化 |
|  优先级调试  | 有抢占式,有也非抢占式 | 区分优先级,适用于实时系统 |        可能导致饥饿         |      会      |        动态/静态优先级         |
| 多级反馈队列 |        抢占式         |         平衡优秀          |         可能会饥饿          |      会      |                                |

注:比起早期的批处理操作系统来说,由于计算机造价大幅降低,因此之后出现的交互式操作系统(包括分时操作系统,实时操作系统等)更注意系统的响应时间,公平性,平衡性等指标.而这几种算法恰好也能较好地满足交互式系统的需求.因此这三种算法适合用于交互式系统.(比如UNIX使用的就是多级反馈队列调试算法)

## 进程同步
> 同步亦称直接制约关系,它是指为完成某种任务而建立的两个或多个进程,这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系.进程间的直接制约关系就是源于它们之间的相互合作.

## 进程互斥
> 我们把一个时间段内只允许一个进程使用的资源称为临界资源.许多物理设备(比如摄像头,打印机)都属于临界资源.此外还有许多变量,数据,内存缓冲区等都属于临界资源.  
> 对临界资源的访问,必须互斥地进程.互斥,亦称间接制约关系.进程互斥指当一个进程访问某临界资源时,另一个想要访问该临界资源的进程必须等待.当前访问临界资源的进程访问结束,释放该资源之后,另一个进程才能访问临界资源.

![](assets/Screenshot%202022-02-21%20194938.png)
为了实现对临界资源的互斥访问,同时保证系统整体性能,需要遵循以下原则:
1. 空闲让进.临界区空闲时,可以允许一个请求进入临界区的进程立即进入临界区.
2. 忙则等待.当已有进程进入临界区时,其他试图进入临界区的进程必须等待.
3. 有限等待.对请求访问的进程,应保证能在有限时间内进入临界区(保证不会饥饿).
4. 让权等待.当进程不能进入临界区时,应当即释放处理机,防止进程忙等待.

### 小结
![](assets/Screenshot%202022-02-21%20195622.png)

## 进程互斥的软件实现方法

### 单标志法
> 算法思想:两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程.也就是说每个进程进入临界区的权限只能被另一个进程赋予

![](assets/Screenshot%202022-02-23%20175755.png)

### 双标志先检查法
> 算法思想:设置一个布尔型数组flag[],数组中各个元素用来标记各进程想进入临界区的意愿,比如
> ```c
> flag[0] = false;
> ```
> 意味着0号进程P0现在想要进入临界区.每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区,如果没有,则把自身对应的标志`flag[i]`设为`true`,之后开始访问临界区.

![](assets/Screenshot%202022-02-24%20203107.png)

### 双标志后检查法
> 算法思想:双标志先检查法的改版.前一个算法的问题是先"检查"后"上锁",但是这两个操作又无法一气可成,因此导致了两个进程同时进入临界区的问题.因此,人们又想到先"上锁"后"检查"的方法,来避免上述问题.

![](assets/Screenshot%202022-02-24%20203817.png)

### Peterson 算法
> 算法思想:双标志后检查法中,两个进程都争着想进入临界区,但是谁也不让谁,最后谁都无法进入临界区.Gary L. Peterson 想到了一种方法,如果双方都争着想进入临界区,那可以让进程尝试"孔融让梨",主动让对方先使用临界区.

![](assets/Screenshot%202022-02-26%20101210.png)
Peterson 算法用软件方法解决了进程互斥问题,遵循了空闲让进,忙则等待,有限等待三个原则,但是依然未遵循让权等待的原则.

### 小结
![](assets/Screenshot%202022-02-26%20102111.png)

## 进程互斥的硬件实现方法
### 中断屏蔽方法
> 利用"开/关中断指令"实现(与原语的实现思想相同,即在某进程开始访问临界区到结束访问为止都不允许被中断,也就不能发生进程切换,因此也不可能发生两个同时访问临界区的情况)

![](assets/Screenshot%202022-02-27%20200248.png)
